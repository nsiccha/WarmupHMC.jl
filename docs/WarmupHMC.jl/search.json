[
  {
    "objectID": "posteriordb.html",
    "href": "posteriordb.html",
    "title": "Using posteriordb reference draws",
    "section": "",
    "text": "# push!(LOAD_PATH,\"../src/\")\nincludet(\"common.jl\")\nusing PosteriorDB\nusing Statistics, LinearAlgebra, ForwardDiff, DataFrames\nusing Plots\nusing Random\nRandom.seed!(1) \n\n\n\"\"\"\nA posteriorDB posterior.\n\"\"\"\n@dynamic_object PDBPosterior name::String\n\ndatabase(what::PDBPosterior) = PosteriorDB.database()\nposterior(what::PDBPosterior) = PosteriorDB.posterior(what.database, what.name)\nmodel(what::PDBPosterior) = PosteriorDB.model(what.posterior)\ndataset(what::PDBPosterior) = PosteriorDB.dataset(what.posterior)\ndatastring(what::PDBPosterior) = PosteriorDB.load(what.dataset, String)\nreference_posterior(what::PDBPosterior) = PosteriorDB.reference_posterior(what.posterior)\nconstrained_df(what::PDBPosterior) = DataFrame(PosteriorDB.load(what.reference_posterior))\nconstrained_draws(what::PDBPosterior) = hcat([vcat(col...) for col in eachcol(what.constrained_df)]...)\nstan_file(what::PDBPosterior) = PosteriorDB.path(PosteriorDB.implementation(what.model, \"stan\"))\nbridgestan_model(what::PDBPosterior) = StanModel(stan_file=what.stan_file, data=what.datastring)\nunconstrained_draws(what::PDBPosterior) = (\n    bmod = what.bridgestan_model;\n    vcat([\n        param_unconstrain(bmod, collect(row))' for row in eachrow(what.constrained_draws)\n    ]...) \n)\n\nunconstrained_draws (generic function with 1 method)\n\n\n\nes_draws = EightSchoolsDraws(PDBPosterior(\"eight_schools-eight_schools_centered\").unconstrained_draws)\nes_draws.scatter_funnel\n\n┌ Warning: Loading a shared object '/home/niko/.julia/artifacts/95c3074bd791a2f28857088639b48ca1b786459a/posteriordb-0.4.0/posterior_database/models/stan/eight_schools_centered_model.so' which is already loaded.\n│ If the file has changed since the last time it was loaded, this load may not update the library!\n└ @ BridgeStan /home/niko/.julia/packages/BridgeStan/ajc6B/src/model.jl:50\n\n\n\n\n\n\n\n\n\nFigure([\n    PlotSum([\n        kl_plot(es_subset, i) for i in 1:8\n    ])\n    for es_subset in subset.([es_draws], [4,8,16,32,64])\n]')\n\n\n\n\n\n\n\n\n\"\"\"\nReparametrizations.\n\"\"\"\n@dynamic_type Reparametrization\n\n@dynamic_object PartialUncentering &lt;: Reparametrization centeredness::Vector\npad_left(what, to_match::AbstractVector) = what\npad_left(what, to_match::AbstractMatrix) = what'\nreparametrize(what::PartialUncentering, parameters) = replace_xcs(\n    parameters,\n    to_xc.(parameters.xcs, parameters.means, parameters.log_sds, pad_left(what.centeredness, parameters.xcs))\n)\nunreparametrize(what::PartialUncentering, reparameters) = replace_xcs(\n    reparameters,\n    to_x1.(reparameters.xcs, reparameters.means, reparameters.log_sds, pad_left(what.centeredness, reparameters.xcs))\n)\nlogjacobian(what::PartialUncentering, parameters, reparameters) = sum(\n    parameters.log_sds .* what.centeredness\n)\n\npu = PartialUncentering(zeros(8))\nres_draws = reparametrize(pu, es_draws)\nres_draws.scatter_funnel\n\n\n\n\n\n\n\n\nes_model = BSModel(PDBPosterior(\"eight_schools-eight_schools_centered\").bridgestan_model)\nres_model = ReparametrizedDistribution(es_model, pu)\n\n# logpdf(res_model, EightSchoolsDraw(zeros(10)))\n\n┌ Warning: Loading a shared object '/home/niko/.julia/artifacts/95c3074bd791a2f28857088639b48ca1b786459a/posteriordb-0.4.0/posterior_database/models/stan/eight_schools_centered_model.so' which is already loaded.\n│ If the file has changed since the last time it was loaded, this load may not update the library!\n└ @ BridgeStan /home/niko/.julia/packages/BridgeStan/ajc6B/src/model.jl:50\n\n\nReparametrizedDistribution(distribution = BSModel(model = StanModel(Ptr{Nothing} @0x0000000009e168d0, Ptr{BridgeStan.StanModelStruct} @0x0000000009938b90, \"{\\n  \\\"J\\\": 8,\\n  \\\"y\\\": [28, 8, -3, 7, -1, 1, 18, 12],\\n  \\\"sigma\\\": [15, 10, 16, 11, 9, 11, 10, 18]\\n}\\n\", 0x000000cc, 0x00000000),), reparametrization = PartialUncentering(centeredness = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],))"
  },
  {
    "objectID": "independent.html",
    "href": "independent.html",
    "title": "Using independent draws",
    "section": "",
    "text": "using DynamicObjects, WarmupHMC\nusing Distributions, Statistics, LinearAlgebra, ForwardDiff\nusing Plots\n\n@dynamic_object WarmupWindow no_iterations::Integer type\n \n@dynamic_object StanWarmup no_iterations::Number adaptation=:metric\nwarmup_windows(what::StanWarmup) = [\n  WarmupWindow(75, :scale)\n  WarmupWindow(25, what.adaptation)\n  WarmupWindow(50, what.adaptation)\n  WarmupWindow(100, what.adaptation)\n  WarmupWindow(200, what.adaptation)\n  WarmupWindow(500, what.adaptation)\n  WarmupWindow(50, :scale)\n]\n\nDistributions.logpdf(what::DynamicObject, parameters) = logpdf(what.distribution, parameters)\nno_dimensions(what::DynamicObject) = length(what.distribution)\nlogpdf_gradient(what::DynamicObject, parameters) = ForwardDiff.gradient(\n  theta-&gt;logpdf(what, theta), parameters\n)\n\n@dynamic_object IndependentKernel distribution::Distribution\n@dynamic_object IndependentKernel distribution::DynamicObject\ntransition(what::IndependentKernel, last) = rand(what.distribution)\n\n@dynamic_object Warmup kernel procedure\n# no_dimensions(what::Warmup) = length(what.kernel.distribution)\nwarmup_windows(what::Warmup) = what.procedure.warmup_windows\ncovariance(what::DynamicObject) = cov(what.distribution)\ncovariance_estimate(what::DynamicObject) = LinearAlgebra.I \nfunction covariance_remaining(what::DynamicObject)\n  ce = what.covariance_estimate\n  L = isa(ce, UniformScaling) ? I : cholesky(ce).L\n  return L \\ what.covariance / L'\nend\nfunction kernels(what::Warmup)\n  current_kernel = what.kernel\n  rv = [current_kernel]\n  fig = missing\n\n  no_dimensions = current_kernel.no_dimensions\n  current_parameters = zeros(no_dimensions)\n\n  for window in what.warmup_windows\n    samples = zeros((window.no_iterations, no_dimensions))\n    gradients = zeros((window.no_iterations, no_dimensions))\n    for iteration in 1:window.no_iterations\n      current_parameters .= transition(current_kernel, current_parameters)\n      samples[iteration, :] .= current_parameters\n      gradients[iteration, :] .= logpdf_gradient(current_kernel, current_parameters)\n    end\n    scov = cov(samples)\n    gcov = cov(gradients)\n    if window.type == :metric\n      # covariance_estimate = regularize(Symmetric(scov), window.no_iterations)\n      covariance_estimate = regularize(Diagonal(sqrt.(diag(scov) ./ diag(gcov))), window.no_iterations)\n      current_kernel = DynamicObjects.update(\n        current_kernel, covariance_estimate=covariance_estimate\n      )\n      push!(rv, current_kernel)\n    end\n    if window.type == :parametrization\n      ismissing(fig) && (fig = vline(current_kernel.distribution.centeredness[1:1], ylim=[0,1]))\n      # klps_plot!(\n      #   fig, \n      #   [x1s(current_kernel.distribution, parameters)[1] for parameters in eachrow(samples)],\n      #   [log_sds(current_kernel.distribution, parameters)[1] for parameters in eachrow(samples)]\n      # )\n      # cs = LinRange(0, 1, 100)\n      # x1 = [x1s(current_kernel.distribution, parameters)[1] for parameters in eachrow(samples)]\n      # sd = [sds(current_kernel.distribution, parameters)[1] for parameters in eachrow(samples)]\n      # # x1, sd = samples[:, 2], samples[:, 1]\n      # kl1s = [klp(x1, log.(sd), c) for c in cs]\n      # kl1s .-= minimum(kl1s)\n      # kl1s ./= maximum(kl1s)\n      # plot!(fig, cs, kl1s)\n      push!(rv, current_kernel)\n    end\n  end\n  !ismissing(fig) && display(fig)\n  return rv\nend\n\nshowcase(no_dimensions::Integer=10) = showcase(\n  MvNormal(randn(no_dimensions), Diagonal(exp.(randn(no_dimensions))))\n)\nfunction showcase(distribution, adaptation=:metric)\n  sw = StanWarmup(1000, adaptation)\n  ikernels = Warmup(IndependentKernel(distribution), sw).kernels\n  iconds = cond.(covariance_remaining.(ikernels))\n  conds = iconds\n  plot(\n    [iconds], yaxis=:log, ylim=[1, maximum(conds)], marker=:circle\n  )\nend\nshowcase()\n\n\n\n\n\n\"\"\"\nNeal's funnel with a twist!\n\"\"\"\n@dynamic_object NealsFunnel centeredness::Vector\nno_dimensions(what::NealsFunnel) = 1+length(what.centeredness)\nBase.length(what::NealsFunnel) = what.no_dimensions\ncenteredness_estimate(what::NealsFunnel) = ones(length(what.centeredness))\ncenteredness_remaining(what::NealsFunnel) = what.centeredness - what.centeredness_estimate\nStatistics.cov(what::NealsFunnel) = LinearAlgebra.I\nlog_sds(what::NealsFunnel, parameters) = exp(parameters[1])\nx1s(what::NealsFunnel, parameters) = parameters[2:end]\nfunction Distributions.logpdf(what::NealsFunnel, parameters) \n  log_sd = parameters[1]\n  sd = exp(log_sd)\n  logpdf(Normal(), log_sd) + sum(logpdf.(Normal.(0, sd.^-what.centeredness_remaining), parameters[2:end]))\nend\nfunction Base.rand(what::NealsFunnel)\n  xis = randn(what.no_dimensions)\n  log_sd = xis[1]\n  sd = exp(log_sd)\n  return vcat(log_sd, sd.^-what.centeredness_remaining .* xis[2:end])\nend\n\nshowcase(NealsFunnel(rand(5)), :parametrization)\n\n\n\n\n\n\n\n\n\"\"\"\nA distribution which looks a bit like an HSGP posterior!\n\"\"\"\n@dynamic_object HSGP centeredness::Vector L=1.5\nno_basis_functions(what::HSGP) = length(what.centeredness)\nindices(what::HSGP) = 1:what.no_basis_functions\nno_dimensions(what::HSGP) = 2+what.no_basis_functions\nBase.length(what::HSGP) = what.no_dimensions\ncenteredness_estimate(what::HSGP) = ones(what.no_basis_functions)\ncenteredness_remaining(what::HSGP) = what.centeredness - what.centeredness_estimate\nStatistics.cov(what::HSGP) = LinearAlgebra.I\n# https://github.com/avehtari/casestudies/blob/master/Birthdays/gpbasisfun_functions.stan\n# alpha * sqrt(sqrt(2*pi()) * rho) * exp(-0.25*(rho*pi()/2/L)^2 * linspaced_vector(M, 1, M)^2)\nfunction sds(what::HSGP, parameters) \n  sd, lengthscale = exp.(parameters[1:2])\n  sd .* sqrt.(sqrt(2pi*lengthscale) .* exp.(-(lengthscale*pi/4/what.L)^2 .* what.indices))\nend\nlog_sds(what::HSGP, parameters) = log.(sds(what, parameters))\nx1s(what::HSGP, parameters) = parameters[3:end]\nfunction Distributions.logpdf(what::HSGP, parameters) \n  log_sd, log_lengthscale = parameters[1:2]\n  sd, lengthscale = exp.([log_sd, log_lengthscale])\n  sum(\n    logpdf.(Normal(), [log_sd, log_lengthscale])\n  ) + sum(\n    logpdf.(Normal.(0, sds(what, parameters).^-what.centeredness_remaining), parameters[3:end])\n  )\nend\nfunction Base.rand(what::HSGP)\n  xis = randn(what.no_dimensions)\n  log_sd, log_lengthscale = xis[1:2]\n  return vcat(log_sd, log_lengthscale, sds(what, parameters).^-what.centeredness_remaining .* xis[3:end])\nend\n\nshowcase(NealsFunnel(rand(5)), :parametrization)"
  }
]