[
  {
    "objectID": "posteriordb_sampling.html",
    "href": "posteriordb_sampling.html",
    "title": "Using posteriordb posteriors",
    "section": "",
    "text": "includet(\"common.jl\")\nusing AdvancedHMC\nRandom.seed!(1) \n\nTaskLocalRNG()\n\n\n\nfunction showcase(centeredness=ones(8), n_samples=20_000, n_adapts=1_000, initial_stepsize=1.)\n    res_posterior = ReparametrizedDistribution(\n        BSDistribution(\n            PDBPosterior(\"eight_schools-eight_schools_centered\").bridgestan_model,\n        ), \n        ContinuousNoncentering(centeredness), wrapper=EightSchoolsDraw\n    )\n    initial_parameters = zeros(res_posterior.no_dimensions)\n    metric = DiagEuclideanMetric(res_posterior.no_dimensions)\n    hamiltonian = Hamiltonian(metric, res_posterior, ReverseDiff)\n    integrator = Leapfrog(initial_stepsize)\n    proposal = NUTS{MultinomialTS, GeneralisedNoUTurn}(integrator)\n    adaptor = StanHMCAdaptor(MassMatrixAdaptor(metric), StepSizeAdaptor(0.8, integrator))\n    samples, stats = sample(hamiltonian, proposal, initial_parameters, n_samples, adaptor, n_adapts; progress=false)\n    EightSchoolsDraws(hcat(samples[1+n_adapts:end]...)')\nend\nshowcase(ones(8)).scatter_funnel \n\n┌ Warning: Loading a shared object '/home/niko/.julia/artifacts/95c3074bd791a2f28857088639b48ca1b786459a/posteriordb-0.4.0/posterior_database/models/stan/eight_schools_centered_model.so' which is already loaded.\n│ If the file has changed since the last time it was loaded, this load may not update the library!\n└ @ BridgeStan /home/niko/.julia/packages/BridgeStan/ajc6B/src/model.jl:50\n┌ Info: Finished 1000 adapation steps\n│   adaptor = StanHMCAdaptor(\n    pc=WelfordVar,\n    ssa=NesterovDualAveraging(γ=0.05, t_0=10.0, κ=0.75, δ=0.8, state.ϵ=0.18205294603176367),\n    init_buffer=75, term_buffer=50, window_size=25,\n    state=window(76, 950), window_splits(100, 150, 250, 450, 950)\n)\n│   κ.τ.integrator = Leapfrog(ϵ=0.182)\n│   h.metric = DiagEuclideanMetric([29.74357500900673, 17.4825 ...])\n└ @ AdvancedHMC /home/niko/.julia/packages/AdvancedHMC/P0nla/src/sampler.jl:223\n\n\n┌ Info: Finished 20000 sampling steps for 1 chains in 19.867921932 (s)\n│   h = Hamiltonian(metric=DiagEuclideanMetric([29.74357500900673, 17.4825 ...]), kinetic=GaussianKinetic())\n│   κ = HMCKernel{AdvancedHMC.FullMomentumRefreshment, Trajectory{MultinomialTS, Leapfrog{Float64}, GeneralisedNoUTurn{Float64}}}(AdvancedHMC.FullMomentumRefreshment(), Trajectory{MultinomialTS}(integrator=Leapfrog(ϵ=0.182), tc=GeneralisedNoUTurn{Float64}(10, 1000.0)))\n│   EBFMI_est = 0.23780181211892362\n│   average_acceptance_rate = 0.7891737575027511\n└ @ AdvancedHMC /home/niko/.julia/packages/AdvancedHMC/P0nla/src/sampler.jl:246\n\n\n\n\n\n\n\n\n\nshowcase(zeros(8)).scatter_funnel \n\n┌ Warning: Loading a shared object '/home/niko/.julia/artifacts/95c3074bd791a2f28857088639b48ca1b786459a/posteriordb-0.4.0/posterior_database/models/stan/eight_schools_centered_model.so' which is already loaded.\n│ If the file has changed since the last time it was loaded, this load may not update the library!\n└ @ BridgeStan /home/niko/.julia/packages/BridgeStan/ajc6B/src/model.jl:50\n┌ Info: Finished 1000 adapation steps\n│   adaptor = StanHMCAdaptor(\n    pc=WelfordVar,\n    ssa=NesterovDualAveraging(γ=0.05, t_0=10.0, κ=0.75, δ=0.8, state.ϵ=0.4629124693929041),\n    init_buffer=75, term_buffer=50, window_size=25,\n    state=window(76, 950), window_splits(100, 150, 250, 450, 950)\n)\n│   κ.τ.integrator = Leapfrog(ϵ=0.463)\n│   h.metric = DiagEuclideanMetric([0.9047161034441294, 0.7823 ...])\n└ @ AdvancedHMC /home/niko/.julia/packages/AdvancedHMC/P0nla/src/sampler.jl:223\n\n\n┌ Info: Finished 20000 sampling steps for 1 chains in 8.377109936 (s)\n│   h = Hamiltonian(metric=DiagEuclideanMetric([0.9047161034441294, 0.7823 ...]), kinetic=GaussianKinetic())\n│   κ = HMCKernel{AdvancedHMC.FullMomentumRefreshment, Trajectory{MultinomialTS, Leapfrog{Float64}, GeneralisedNoUTurn{Float64}}}(AdvancedHMC.FullMomentumRefreshment(), Trajectory{MultinomialTS}(integrator=Leapfrog(ϵ=0.463), tc=GeneralisedNoUTurn{Float64}(10, 1000.0)))\n│   EBFMI_est = 0.9969619938816938\n│   average_acceptance_rate = 0.848637796106458\n└ @ AdvancedHMC /home/niko/.julia/packages/AdvancedHMC/P0nla/src/sampler.jl:246"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "WarmupHMC.jl examples",
    "section": "",
    "text": "WIP, postdoctoral advisory recommended/required."
  },
  {
    "objectID": "independent.html",
    "href": "independent.html",
    "title": "Using independent draws",
    "section": "",
    "text": "using DynamicObjects, WarmupHMC\nusing Distributions, Statistics, LinearAlgebra, ForwardDiff\nusing Plots\n\n@dynamic_object WarmupWindow no_iterations::Integer type\n \n@dynamic_object StanWarmup no_iterations::Number adaptation=:metric\nwarmup_windows(what::StanWarmup) = [\n  WarmupWindow(75, :scale)\n  WarmupWindow(25, what.adaptation)\n  WarmupWindow(50, what.adaptation)\n  WarmupWindow(100, what.adaptation)\n  WarmupWindow(200, what.adaptation)\n  WarmupWindow(500, what.adaptation)\n  WarmupWindow(50, :scale)\n]\n\nDistributions.logpdf(what::DynamicObject, parameters) = logpdf(what.distribution, parameters)\nno_dimensions(what::DynamicObject) = length(what.distribution)\nlogpdf_gradient(what::DynamicObject, parameters) = ForwardDiff.gradient(\n  theta-&gt;logpdf(what, theta), parameters\n)\n\n@dynamic_object IndependentKernel distribution::Distribution\n@dynamic_object IndependentKernel distribution::DynamicObject\ntransition(what::IndependentKernel, last) = rand(what.distribution)\n\n@dynamic_object Warmup kernel procedure\n# no_dimensions(what::Warmup) = length(what.kernel.distribution)\nwarmup_windows(what::Warmup) = what.procedure.warmup_windows\ncovariance(what::DynamicObject) = cov(what.distribution)\ncovariance_estimate(what::DynamicObject) = LinearAlgebra.I \nfunction covariance_remaining(what::DynamicObject)\n  ce = what.covariance_estimate\n  L = isa(ce, UniformScaling) ? I : cholesky(ce).L\n  return L \\ what.covariance / L'\nend\nfunction kernels(what::Warmup)\n  current_kernel = what.kernel\n  rv = [current_kernel]\n  fig = missing\n\n  no_dimensions = current_kernel.no_dimensions\n  current_parameters = zeros(no_dimensions)\n\n  for window in what.warmup_windows\n    samples = zeros((window.no_iterations, no_dimensions))\n    gradients = zeros((window.no_iterations, no_dimensions))\n    for iteration in 1:window.no_iterations\n      current_parameters .= transition(current_kernel, current_parameters)\n      samples[iteration, :] .= current_parameters\n      gradients[iteration, :] .= logpdf_gradient(current_kernel, current_parameters)\n    end\n    scov = cov(samples)\n    gcov = cov(gradients)\n    if window.type == :metric\n      # covariance_estimate = regularize(Symmetric(scov), window.no_iterations)\n      covariance_estimate = regularize(Diagonal(sqrt.(diag(scov) ./ diag(gcov))), window.no_iterations)\n      current_kernel = DynamicObjects.update(\n        current_kernel, covariance_estimate=covariance_estimate\n      )\n      push!(rv, current_kernel)\n    end\n    if window.type == :parametrization\n      ismissing(fig) && (fig = vline(current_kernel.distribution.centeredness[1:1], ylim=[0,1]))\n      # klps_plot!(\n      #   fig, \n      #   [x1s(current_kernel.distribution, parameters)[1] for parameters in eachrow(samples)],\n      #   [log_sds(current_kernel.distribution, parameters)[1] for parameters in eachrow(samples)]\n      # )\n      # cs = LinRange(0, 1, 100)\n      # x1 = [x1s(current_kernel.distribution, parameters)[1] for parameters in eachrow(samples)]\n      # sd = [sds(current_kernel.distribution, parameters)[1] for parameters in eachrow(samples)]\n      # # x1, sd = samples[:, 2], samples[:, 1]\n      # kl1s = [klp(x1, log.(sd), c) for c in cs]\n      # kl1s .-= minimum(kl1s)\n      # kl1s ./= maximum(kl1s)\n      # plot!(fig, cs, kl1s)\n      push!(rv, current_kernel)\n    end\n  end\n  !ismissing(fig) && display(fig)\n  return rv\nend\n\nshowcase(no_dimensions::Integer=10) = showcase(\n  MvNormal(randn(no_dimensions), Diagonal(exp.(randn(no_dimensions))))\n)\nfunction showcase(distribution, adaptation=:metric)\n  sw = StanWarmup(1000, adaptation)\n  ikernels = Warmup(IndependentKernel(distribution), sw).kernels\n  iconds = cond.(covariance_remaining.(ikernels))\n  conds = iconds\n  plot(\n    [iconds], yaxis=:log, ylim=[1, maximum(conds)], marker=:circle\n  )\nend\nshowcase()\n\n\n\n\n\n\"\"\"\nNeal's funnel with a twist!\n\"\"\"\n@dynamic_object NealsFunnel centeredness::Vector\nno_dimensions(what::NealsFunnel) = 1+length(what.centeredness)\nBase.length(what::NealsFunnel) = what.no_dimensions\ncenteredness_estimate(what::NealsFunnel) = ones(length(what.centeredness))\ncenteredness_remaining(what::NealsFunnel) = what.centeredness - what.centeredness_estimate\nStatistics.cov(what::NealsFunnel) = LinearAlgebra.I\nlog_sds(what::NealsFunnel, parameters) = exp(parameters[1])\nx1s(what::NealsFunnel, parameters) = parameters[2:end]\nfunction Distributions.logpdf(what::NealsFunnel, parameters) \n  log_sd = parameters[1]\n  sd = exp(log_sd)\n  logpdf(Normal(), log_sd) + sum(logpdf.(Normal.(0, sd.^-what.centeredness_remaining), parameters[2:end]))\nend\nfunction Base.rand(what::NealsFunnel)\n  xis = randn(what.no_dimensions)\n  log_sd = xis[1]\n  sd = exp(log_sd)\n  return vcat(log_sd, sd.^-what.centeredness_remaining .* xis[2:end])\nend\n\nshowcase(NealsFunnel(rand(5)), :parametrization)\n\n\n\n\n\n\n\n\n\"\"\"\nA distribution which looks a bit like an HSGP posterior!\n\"\"\"\n@dynamic_object HSGP centeredness::Vector L=1.5\nno_basis_functions(what::HSGP) = length(what.centeredness)\nindices(what::HSGP) = 1:what.no_basis_functions\nno_dimensions(what::HSGP) = 2+what.no_basis_functions\nBase.length(what::HSGP) = what.no_dimensions\ncenteredness_estimate(what::HSGP) = ones(what.no_basis_functions)\ncenteredness_remaining(what::HSGP) = what.centeredness - what.centeredness_estimate\nStatistics.cov(what::HSGP) = LinearAlgebra.I\n# https://github.com/avehtari/casestudies/blob/master/Birthdays/gpbasisfun_functions.stan\n# alpha * sqrt(sqrt(2*pi()) * rho) * exp(-0.25*(rho*pi()/2/L)^2 * linspaced_vector(M, 1, M)^2)\nfunction sds(what::HSGP, parameters) \n  sd, lengthscale = exp.(parameters[1:2])\n  sd .* sqrt.(sqrt(2pi*lengthscale) .* exp.(-(lengthscale*pi/4/what.L)^2 .* what.indices))\nend\nlog_sds(what::HSGP, parameters) = log.(sds(what, parameters))\nx1s(what::HSGP, parameters) = parameters[3:end]\nfunction Distributions.logpdf(what::HSGP, parameters) \n  log_sd, log_lengthscale = parameters[1:2]\n  sd, lengthscale = exp.([log_sd, log_lengthscale])\n  sum(\n    logpdf.(Normal(), [log_sd, log_lengthscale])\n  ) + sum(\n    logpdf.(Normal.(0, sds(what, parameters).^-what.centeredness_remaining), parameters[3:end])\n  )\nend\nfunction Base.rand(what::HSGP)\n  xis = randn(what.no_dimensions)\n  log_sd, log_lengthscale = xis[1:2]\n  return vcat(log_sd, log_lengthscale, sds(what, parameters).^-what.centeredness_remaining .* xis[3:end])\nend\n\nshowcase(NealsFunnel(rand(5)), :parametrization)"
  },
  {
    "objectID": "posteriordb_independent.html",
    "href": "posteriordb_independent.html",
    "title": "Using posteriordb reference draws",
    "section": "",
    "text": "includet(\"common.jl\")\nRandom.seed!(1) \n\nTaskLocalRNG()\n\n\n\nes_draws = EightSchoolsDraws(PDBPosterior(\"eight_schools-eight_schools_centered\").unconstrained_draws)\n\nnc_es_draws = reparametrize(ContinuousNoncentering(zeros(8)), es_draws)\nnc_es_draws.scatter_funnel\n\nbc_es_pu = ContinuousNoncentering(es_draws.best_centeredness)\nbc_es_draws = reparametrize(bc_es_pu, es_draws)\ndisplay(Line(1:es_draws.no_xcs, bc_es_pu.centeredness))\nFigure([\n    scatter_funnel(draws, i)\n    for i in 1:8, draws in [es_draws, nc_es_draws, bc_es_draws]\n])\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nmc_draws = MotorcycleDraws(PDBPosterior(\"mcycle_gp-accel_gp\").unconstrained_draws)\nc_pu = ContinuousNoncentering(ones(mc_draws.no_xcs), previous_centeredness=0) \nc_mc_draws = reparametrize(c_pu, mc_draws)\nbc_mc_pu = ContinuousNoncentering(mc_draws.best_centeredness, previous_centeredness=0)\nbc_mc_draws = reparametrize(bc_mc_pu, mc_draws)\ndisplay(Line(1:mc_draws.no_xcs, bc_mc_pu.centeredness))\n\nFigure([\n    scatter_funnel(draws, i)\n    for i in 1:mc_draws.no_xcs, draws in [mc_draws, c_mc_draws, bc_mc_draws]\n])"
  }
]