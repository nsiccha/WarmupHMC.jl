[
  {
    "objectID": "posteriordb_sampling.html",
    "href": "posteriordb_sampling.html",
    "title": "Using posteriordb posteriors",
    "section": "",
    "text": "if pwd()[end] != 's'\n    using Revise\n    using Pkg\n    cd(\"examples\")\n    Pkg.activate(\".\")\nend\nincludet(\"common.jl\")\nusing AdvancedHMC\nRandom.seed!(1) \n\n@dynamic_object MarkovChain distribution::DynamicDistribution no_draws initial_parameters adapt=false\nno_dimensions(what::MarkovChain) = what.distribution.no_dimensions\nmetric(what::MarkovChain) = DiagEuclideanMetric(what.distribution.no_dimensions)\nhamiltonian(what::MarkovChain) = Hamiltonian(what.metric, what.distribution, ReverseDiff)\nintegrator(what::MarkovChain) = Leapfrog(1.)\ncompleted(what::MarkovChain) = DynamicObjects.update(what, :stepsize_draws_stats)\ncompleted(what::MarkovChain, no_draws; kwargs...) = DynamicObjects.update(\n    what, no_draws=no_draws; kwargs...\n).completed\n\nfunction stepsize_draws_stats(what::MarkovChain)\n    no_draws = what.no_draws\n    initial_parameters = what.initial_parameters\n    adapt = what.adapt\n    hamiltonian = what.hamiltonian\n    integrator = what.integrator\n    proposal = NUTS{MultinomialTS, GeneralisedNoUTurn}(integrator)\n    if adapt\n        adaptor = StepSizeAdaptor(0.8, integrator)\n        samples, stats = sample(\n            hamiltonian, proposal, initial_parameters, no_draws, adaptor, no_draws; \n            progress=true, verbose=false\n        )\n        AdvancedHMC.finalize!(adaptor)\n        return adaptor.state.ϵ, hcat(samples...)', stats\n    else\n        samples, stats = sample(\n            hamiltonian, proposal, initial_parameters, no_draws; \n            progress=true, verbose=false\n        )\n        return 1., hcat(samples...)', stats\n    end\nend \nstepsize(what::MarkovChain) = what.stepsize_draws_stats[1]\ndraws(what::MarkovChain) = what.stepsize_draws_stats[2]\nstats(what::MarkovChain) = what.stepsize_draws_stats[3]\nunreparametrized_draws(what::MarkovChain) = unreparametrize(what.distribution, what.draws)\nunreparametrized_stds(what::MarkovChain) = std.(eachcol(what.unreparametrized_draws))\nunreparametrized_esss(what::MarkovChain) = ess(\n    reshape(what.unreparametrized_draws, (size(what.draws, 1), 1, size(what.draws, 2)))\n)\nunreparametrized_effs(what::MarkovChain) = what.unreparametrized_esss ./ sum(what.stats_df.n_steps)\nrescaled_distribution(what::MarkovChain) = rescale(what.distribution, [what.stepsize])\nfinal_parameters(what::MarkovChain) = what.draws[end, :]\nrescaled(what::MarkovChain) = MarkovChain(\n    what.rescaled_distribution, what.no_draws, what.stepsize .\\ what.final_parameters, what.adapt\n)\nfunction reparametrized_distribution(what::MarkovChain)\n    display(what.stats_df_description)\n    repa_distribution = what.distribution\n    base_distribution = repa_distribution.distribution\n    if hasproperty(base_distribution, :wrapper)\n        draws = unreparametrize(repa_distribution, what.draws)\n        # println(\"Obtained odraws: $(typeof(odraws)), $(size(odraws))\")\n        bc = base_distribution.wrapper(draws).best_centeredness\n        println(\"Obtained bc: $(bc)\")\n        repa_distribution = recenter(base_distribution, bc)\n        # println(\"Recenterd distributions\")\n        draws = reparametrize(repa_distribution, draws)\n        rescale(repa_distribution, std.(eachcol(draws)))\n    else\n        # repa_distribution = base_distribution\n        rescale(what.distribution, std.(eachcol(what.draws)))\n    end\n    # println(\"Reparametrized draws\")\n    # rescale(repa_distribution, std.(eachcol(draws)))\nend   \nfunction reparametrized(what::MarkovChain)\n    repa_distribution = what.reparametrized_distribution\n    initial_parameters = reparametrize(\n        repa_distribution, unreparametrize(what.distribution, what.final_parameters)\n    )\n    MarkovChain(repa_distribution, what.no_draws, initial_parameters, what.adapt)\nend\nstats_df(what::MarkovChain) = DataFrame(what.stats)\nstats_df_description(what::MarkovChain) = describe(what.stats_df)[[1,3,9], 1:5]\n# MCMCDiagnosticTools.ess(what::MarkovChain) = ess(what.unreparametrized_draws)\n\nBase.show(io::IOContext{IOBuffer}, what::MarkovChain) = (\n    display(describe(what.stats_df)[[1,3,9], 1:5]);\n    display(PairPlots(what.draws))\n    # display(plot(what.distribution.reparametrization.reparametrizations[end].reparametrizations[end].centeredness))\n)  \n \n@dynamic_object MarkovChainComparison chains::AbstractVector \nlhs(what::MarkovChainComparison) = what.chains[1]\nno_pairplot_parameters(what::MarkovChainComparison) = 20\n# pairplot_idxs(what::MarkovChainComparison) = sort(\n#         sample(axes(what.lhs.draws, 2), \n#         min(what.no_pairplot_parameters, size(what.lhs.draws, 2)), replace=false\n#     )\n# )\nfunction pairplot_idxs(what::MarkovChainComparison)\n    # println(size(unreparametrized_esss(what.chains[1])))\n    # stds = hcat(unreparametrized_stds.(what.chains)...)\n    effs = hcat(unreparametrized_effs.(what.chains)...)\n\n    metric = vec(minimum(effs, dims=2))\n    no_parameters = length(metric)\n    sort(\n        sort(1:no_parameters, by=i-&gt;metric[i])[\n            1:min(no_parameters, what.no_pairplot_parameters)\n        ]\n    )\nend\nBase.show(io::IOContext{IOBuffer}, what::MarkovChainComparison) = (\n    display.(stats_df_description.(what.chains));\n    display(plot(hcat(unreparametrized_effs.(what.chains)...)));\n    pairplot_idxs = what.pairplot_idxs;\n    display(sum([\n        PairPlots(chain.unreparametrized_draws, pairplot_idxs) for chain in what.chains\n    ]))\n)\n\ninitial_parameters(what::DynamicDistribution) = zeros(what.no_dimensions)\ninitial_stepsize(what::DynamicDistribution) = 1.\nfunction adaptation(what::DynamicDistribution)\n    initial_parameters = what.initial_parameters\n    while !all(isfinite.(log_density_gradient(what.model, initial_parameters)[2]))\n        initial_parameters = randn(size(initial_parameters))\n    end\n    what = rescale(what, [what.initial_stepsize])\n    mc = MarkovChain(what, 75, what.initial_stepsize .\\ initial_parameters, true).completed.rescaled\n    for no_draws in [25, 50, 100, 200, 500]\n        mc = completed(mc, no_draws).reparametrized\n    end\n    completed(mc, 50).rescaled\nend \nadapted_draws(what::DynamicDistribution) = completed(what.adaptation, 1000, adapt=false)\n\nadapted_draws (generic function with 1 method)\n\n\n\nwhat = DynamicObjects.cached(\n    PDBPosterior(\"eight_schools-eight_schools_centered\").bridgestan_distribution, \n    :adapted_draws\n)\nwhata = DynamicObjects.cached(\n    DynamicObjects.update(\n        PDBPosterior(\"eight_schools-eight_schools_centered\").bridgestan_distribution, \n        wrapper=eight_schools_wrapper,\n        centeredness=1\n    ), \n    :adapted_draws\n)\nMarkovChainComparison([whata, what])\n\n┌ Warning: Loading a shared object '/home/niko/.julia/artifacts/95c3074bd791a2f28857088639b48ca1b786459a/posteriordb-0.4.0/posterior_database/models/stan/eight_schools_centered_model.so' which is already loaded.\n│ If the file has changed since the last time it was loaded, this load may not update the library!\n└ @ BridgeStan /home/niko/.julia/packages/BridgeStan/ajc6B/src/model.jl:50\n\n\n3×5 DataFrame\n\n\n\nRow\nvariable\nmean\nmin\nmedian\nmax\n\n\n\nSymbol\nFloat64\nReal\nFloat64\nReal\n\n\n\n\n1\nn_steps\n11.664\n3\n7.0\n47\n\n\n2\nacceptance_rate\n0.93227\n0.013365\n0.971526\n1.0\n\n\n3\nnumerical_error\n0.0\nfalse\n0.0\nfalse\n\n\n\n\n\n\n3×5 DataFrame\n\n\n\nRow\nvariable\nmean\nmin\nmedian\nmax\n\n\n\nSymbol\nFloat64\nReal\nFloat64\nReal\n\n\n\n\n1\nn_steps\n20.387\n1\n15.0\n95\n\n\n2\nacceptance_rate\n0.817493\n2.13754e-39\n0.942355\n1.0\n\n\n3\nnumerical_error\n0.011\nfalse\n0.0\ntrue\n\n\n\n\n\n\n\n\n\nSaving figs/1378263685755976720.png.\n\n\n\n\n\n\n\n\n\n\n\n\nwhat = DynamicObjects.cached(\n    PDBPosterior(\"radon_mn-radon_hierarchical_intercept_centered\").bridgestan_distribution, \n    :adapted_draws\n)\nwhata = DynamicObjects.cached(\n    DynamicObjects.update(\n        PDBPosterior(\"radon_mn-radon_hierarchical_intercept_centered\").bridgestan_distribution, \n        wrapper=radon_wrapper,\n        centeredness=1\n    ), \n    :adapted_draws\n)\nMarkovChainComparison([whata, what])\n\n┌ Warning: Loading a shared object '/home/niko/.julia/artifacts/95c3074bd791a2f28857088639b48ca1b786459a/posteriordb-0.4.0/posterior_database/models/stan/radon_hierarchical_intercept_centered_model.so' which is already loaded.\n│ If the file has changed since the last time it was loaded, this load may not update the library!\n└ @ BridgeStan /home/niko/.julia/packages/BridgeStan/ajc6B/src/model.jl:50\n\n\n3×5 DataFrame\n\n\n\nRow\nvariable\nmean\nmin\nmedian\nmax\n\n\n\nSymbol\nFloat64\nReal\nFloat64\nReal\n\n\n\n\n1\nn_steps\n16.8\n7\n7.0\n167\n\n\n2\nacceptance_rate\n0.8552\n0.328567\n0.882215\n1.0\n\n\n3\nnumerical_error\n0.0\nfalse\n0.0\nfalse\n\n\n\n\n\n\n3×5 DataFrame\n\n\n\nRow\nvariable\nmean\nmin\nmedian\nmax\n\n\n\nSymbol\nFloat64\nReal\nFloat64\nReal\n\n\n\n\n1\nn_steps\n20.12\n7\n15.0\n255\n\n\n2\nacceptance_rate\n0.912937\n0.334626\n0.950616\n1.0\n\n\n3\nnumerical_error\n0.0\nfalse\n0.0\nfalse\n\n\n\n\n\n\n\n\n\nSaving figs/10191184992519741203.png.\n\n\n\n\n\n\n\n\n\n\n\n\nwhat = DynamicObjects.cached(\n    PDBPosterior(\"radon_all-radon_hierarchical_intercept_centered\").bridgestan_distribution, \n    :adapted_draws\n)\nwhata = DynamicObjects.cached(\n    DynamicObjects.update(\n        PDBPosterior(\"radon_all-radon_hierarchical_intercept_centered\").bridgestan_distribution, \n        wrapper=radon_wrapper,\n        centeredness=1\n    ), \n    :adapted_draws\n)\nMarkovChainComparison([whata, what])\n\n┌ Warning: Loading a shared object '/home/niko/.julia/artifacts/95c3074bd791a2f28857088639b48ca1b786459a/posteriordb-0.4.0/posterior_database/models/stan/radon_hierarchical_intercept_centered_model.so' which is already loaded.\n│ If the file has changed since the last time it was loaded, this load may not update the library!\n└ @ BridgeStan /home/niko/.julia/packages/BridgeStan/ajc6B/src/model.jl:50\n┌ Warning: Loading a shared object '/home/niko/.julia/artifacts/95c3074bd791a2f28857088639b48ca1b786459a/posteriordb-0.4.0/posterior_database/models/stan/radon_hierarchical_intercept_centered_model.so' which is already loaded.\n│ If the file has changed since the last time it was loaded, this load may not update the library!\n└ @ BridgeStan /home/niko/.julia/packages/BridgeStan/ajc6B/src/model.jl:50\n\n\n3×5 DataFrame\n\n\n\nRow\nvariable\nmean\nmin\nmedian\nmax\n\n\n\nSymbol\nFloat64\nReal\nFloat64\nReal\n\n\n\n\n1\nn_steps\n30.936\n15\n31.0\n31\n\n\n2\nacceptance_rate\n0.908669\n0.329654\n0.94109\n1.0\n\n\n3\nnumerical_error\n0.0\nfalse\n0.0\nfalse\n\n\n\n\n\n\n3×5 DataFrame\n\n\n\nRow\nvariable\nmean\nmin\nmedian\nmax\n\n\n\nSymbol\nFloat64\nReal\nFloat64\nReal\n\n\n\n\n1\nn_steps\n31.0\n31\n31.0\n31\n\n\n2\nacceptance_rate\n0.930547\n0.528062\n0.95366\n1.0\n\n\n3\nnumerical_error\n0.0\nfalse\n0.0\nfalse\n\n\n\n\n\n\n\n\n\nSaving figs/21617286779126334.png.\n\n\n\n\n\n\n\n\n\n\n\n\nwhat = DynamicObjects.cached(\n    PDBPosterior(\"radon_all-radon_variable_intercept_slope_centered\").bridgestan_distribution, \n    :adapted_draws\n)\nwhata = DynamicObjects.cached(\n    DynamicObjects.update(\n        PDBPosterior(\"radon_all-radon_variable_intercept_slope_centered\").bridgestan_distribution, \n        wrapper=radon_is_wrapper,\n        centeredness=1\n    ), \n    :adapted_draws\n)\nMarkovChainComparison([whata, what])\n\n┌ Warning: Loading a shared object '/home/niko/.julia/artifacts/95c3074bd791a2f28857088639b48ca1b786459a/posteriordb-0.4.0/posterior_database/models/stan/radon_variable_intercept_slope_centered_model.so' which is already loaded.\n│ If the file has changed since the last time it was loaded, this load may not update the library!\n└ @ BridgeStan /home/niko/.julia/packages/BridgeStan/ajc6B/src/model.jl:50\n\n\n3×5 DataFrame\n\n\n\nRow\nvariable\nmean\nmin\nmedian\nmax\n\n\n\nSymbol\nFloat64\nReal\nFloat64\nReal\n\n\n\n\n1\nn_steps\n15.0\n15\n15.0\n15\n\n\n2\nacceptance_rate\n0.852716\n0.439509\n0.878137\n1.0\n\n\n3\nnumerical_error\n0.0\nfalse\n0.0\nfalse\n\n\n\n\n\n\n3×5 DataFrame\n\n\n\nRow\nvariable\nmean\nmin\nmedian\nmax\n\n\n\nSymbol\nFloat64\nReal\nFloat64\nReal\n\n\n\n\n1\nn_steps\n15.256\n15\n15.0\n63\n\n\n2\nacceptance_rate\n0.860893\n0.393401\n0.890576\n1.0\n\n\n3\nnumerical_error\n0.0\nfalse\n0.0\nfalse\n\n\n\n\n\n\n\n\n\nSaving figs/8443362940302346461.png.\n\n\n\n\n\n\n\n\n\n\n\n\nwhat = DynamicObjects.cached(\n    DynamicObjects.update(\n        PDBPosterior(\"mcycle_gp-accel_gp\").bridgestan_distribution, \n        initial_parameters=vec(mean(PDBPosterior(\"mcycle_gp-accel_gp\").unconstrained_draws, dims=1)),\n        initial_stepsize=1e-1\n    ), \n    :adapted_draws\n) \nwhata = DynamicObjects.cached(\n    DynamicObjects.update(\n        PDBPosterior(\"mcycle_gp-accel_gp\").bridgestan_distribution, \n        wrapper=motorcycle_wrapper,\n        centeredness=0,\n        initial_parameters=vec(mean(PDBPosterior(\"mcycle_gp-accel_gp\").unconstrained_draws, dims=1)),\n        initial_stepsize=1e-1\n    ), \n    :adapted_draws\n)\nMarkovChainComparison([whata, what])\n# PairPlots(what.draws)\n\n┌ Warning: Loading a shared object '/home/niko/.julia/artifacts/95c3074bd791a2f28857088639b48ca1b786459a/posteriordb-0.4.0/posterior_database/models/stan/accel_gp_model.so' which is already loaded.\n│ If the file has changed since the last time it was loaded, this load may not update the library!\n└ @ BridgeStan /home/niko/.julia/packages/BridgeStan/ajc6B/src/model.jl:50\n┌ Warning: Loading a shared object '/home/niko/.julia/artifacts/95c3074bd791a2f28857088639b48ca1b786459a/posteriordb-0.4.0/posterior_database/models/stan/accel_gp_model.so' which is already loaded.\n│ If the file has changed since the last time it was loaded, this load may not update the library!\n└ @ BridgeStan /home/niko/.julia/packages/BridgeStan/ajc6B/src/model.jl:50\n┌ Warning: Loading a shared object '/home/niko/.julia/artifacts/95c3074bd791a2f28857088639b48ca1b786459a/posteriordb-0.4.0/posterior_database/models/stan/accel_gp_model.so' which is already loaded.\n│ If the file has changed since the last time it was loaded, this load may not update the library!\n└ @ BridgeStan /home/niko/.julia/packages/BridgeStan/ajc6B/src/model.jl:50\n\n\n3×5 DataFrame\n\n\n\nRow\nvariable\nmean\nmin\nmedian\nmax\n\n\n\nSymbol\nFloat64\nReal\nFloat64\nReal\n\n\n\n\n1\nn_steps\n559.512\n130\n511.0\n1023\n\n\n2\nacceptance_rate\n0.919255\n0.00930776\n0.964852\n1.0\n\n\n3\nnumerical_error\n0.005\nfalse\n0.0\ntrue\n\n\n\n\n\n\n3×5 DataFrame\n\n\n\nRow\nvariable\nmean\nmin\nmedian\nmax\n\n\n\nSymbol\nFloat64\nReal\nFloat64\nReal\n\n\n\n\n1\nn_steps\n1004.11\n383\n1023.0\n1023\n\n\n2\nacceptance_rate\n0.953261\n0.185113\n0.983872\n0.999997\n\n\n3\nnumerical_error\n0.001\nfalse\n0.0\ntrue\n\n\n\n\n\n\n\n\n\nSaving figs/17325447436755287898.png."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "WarmupHMC.jl examples",
    "section": "",
    "text": "WIP, postdoctoral advisory recommended/required."
  },
  {
    "objectID": "independent.html",
    "href": "independent.html",
    "title": "Using independent draws",
    "section": "",
    "text": "using DynamicObjects, WarmupHMC\nusing Distributions, Statistics, LinearAlgebra, ForwardDiff\nusing Plots\n\n@dynamic_object WarmupWindow no_iterations::Integer type\n \n@dynamic_object StanWarmup no_iterations::Number adaptation=:metric\nwarmup_windows(what::StanWarmup) = [\n  WarmupWindow(75, :scale)\n  WarmupWindow(25, what.adaptation)\n  WarmupWindow(50, what.adaptation)\n  WarmupWindow(100, what.adaptation)\n  WarmupWindow(200, what.adaptation)\n  WarmupWindow(500, what.adaptation)\n  WarmupWindow(50, :scale)\n]\n\nDistributions.logpdf(what::DynamicObject, parameters) = logpdf(what.distribution, parameters)\nno_dimensions(what::DynamicObject) = length(what.distribution)\nlogpdf_gradient(what::DynamicObject, parameters) = ForwardDiff.gradient(\n  theta-&gt;logpdf(what, theta), parameters\n)\n\n@dynamic_object IndependentKernel distribution::Distribution\n@dynamic_object IndependentKernel distribution::DynamicObject\ntransition(what::IndependentKernel, last) = rand(what.distribution)\n\n@dynamic_object Warmup kernel procedure\n# no_dimensions(what::Warmup) = length(what.kernel.distribution)\nwarmup_windows(what::Warmup) = what.procedure.warmup_windows\ncovariance(what::DynamicObject) = cov(what.distribution)\ncovariance_estimate(what::DynamicObject) = LinearAlgebra.I \nfunction covariance_remaining(what::DynamicObject)\n  ce = what.covariance_estimate\n  L = isa(ce, UniformScaling) ? I : cholesky(ce).L\n  return L \\ what.covariance / L'\nend\nfunction kernels(what::Warmup)\n  current_kernel = what.kernel\n  rv = [current_kernel]\n  fig = missing\n\n  no_dimensions = current_kernel.no_dimensions\n  current_parameters = zeros(no_dimensions)\n\n  for window in what.warmup_windows\n    samples = zeros((window.no_iterations, no_dimensions))\n    gradients = zeros((window.no_iterations, no_dimensions))\n    for iteration in 1:window.no_iterations\n      current_parameters .= transition(current_kernel, current_parameters)\n      samples[iteration, :] .= current_parameters\n      gradients[iteration, :] .= logpdf_gradient(current_kernel, current_parameters)\n    end\n    scov = cov(samples)\n    gcov = cov(gradients)\n    if window.type == :metric\n      # covariance_estimate = regularize(Symmetric(scov), window.no_iterations)\n      covariance_estimate = regularize(Diagonal(sqrt.(diag(scov) ./ diag(gcov))), window.no_iterations)\n      current_kernel = DynamicObjects.update(\n        current_kernel, covariance_estimate=covariance_estimate\n      )\n      push!(rv, current_kernel)\n    end\n    if window.type == :parametrization\n      ismissing(fig) && (fig = vline(current_kernel.distribution.centeredness[1:1], ylim=[0,1]))\n      # klps_plot!(\n      #   fig, \n      #   [x1s(current_kernel.distribution, parameters)[1] for parameters in eachrow(samples)],\n      #   [log_sds(current_kernel.distribution, parameters)[1] for parameters in eachrow(samples)]\n      # )\n      # cs = LinRange(0, 1, 100)\n      # x1 = [x1s(current_kernel.distribution, parameters)[1] for parameters in eachrow(samples)]\n      # sd = [sds(current_kernel.distribution, parameters)[1] for parameters in eachrow(samples)]\n      # # x1, sd = samples[:, 2], samples[:, 1]\n      # kl1s = [klp(x1, log.(sd), c) for c in cs]\n      # kl1s .-= minimum(kl1s)\n      # kl1s ./= maximum(kl1s)\n      # plot!(fig, cs, kl1s)\n      push!(rv, current_kernel)\n    end\n  end\n  !ismissing(fig) && display(fig)\n  return rv\nend\n\nshowcase(no_dimensions::Integer=10) = showcase(\n  MvNormal(randn(no_dimensions), Diagonal(exp.(randn(no_dimensions))))\n)\nfunction showcase(distribution, adaptation=:metric)\n  sw = StanWarmup(1000, adaptation)\n  ikernels = Warmup(IndependentKernel(distribution), sw).kernels\n  iconds = cond.(covariance_remaining.(ikernels))\n  conds = iconds\n  plot(\n    [iconds], yaxis=:log, ylim=[1, maximum(conds)], marker=:circle\n  )\nend\nshowcase()\n\n\n\n\n\n\"\"\"\nNeal's funnel with a twist!\n\"\"\"\n@dynamic_object NealsFunnel centeredness::Vector\nno_dimensions(what::NealsFunnel) = 1+length(what.centeredness)\nBase.length(what::NealsFunnel) = what.no_dimensions\ncenteredness_estimate(what::NealsFunnel) = ones(length(what.centeredness))\ncenteredness_remaining(what::NealsFunnel) = what.centeredness - what.centeredness_estimate\nStatistics.cov(what::NealsFunnel) = LinearAlgebra.I\nlog_sds(what::NealsFunnel, parameters) = exp(parameters[1])\nx1s(what::NealsFunnel, parameters) = parameters[2:end]\nfunction Distributions.logpdf(what::NealsFunnel, parameters) \n  log_sd = parameters[1]\n  sd = exp(log_sd)\n  logpdf(Normal(), log_sd) + sum(logpdf.(Normal.(0, sd.^-what.centeredness_remaining), parameters[2:end]))\nend\nfunction Base.rand(what::NealsFunnel)\n  xis = randn(what.no_dimensions)\n  log_sd = xis[1]\n  sd = exp(log_sd)\n  return vcat(log_sd, sd.^-what.centeredness_remaining .* xis[2:end])\nend\n\nshowcase(NealsFunnel(rand(5)), :parametrization)\n\n\n\n\n\n\n\n\n\"\"\"\nA distribution which looks a bit like an HSGP posterior!\n\"\"\"\n@dynamic_object HSGP centeredness::Vector L=1.5\nno_basis_functions(what::HSGP) = length(what.centeredness)\nindices(what::HSGP) = 1:what.no_basis_functions\nno_dimensions(what::HSGP) = 2+what.no_basis_functions\nBase.length(what::HSGP) = what.no_dimensions\ncenteredness_estimate(what::HSGP) = ones(what.no_basis_functions)\ncenteredness_remaining(what::HSGP) = what.centeredness - what.centeredness_estimate\nStatistics.cov(what::HSGP) = LinearAlgebra.I\n# https://github.com/avehtari/casestudies/blob/master/Birthdays/gpbasisfun_functions.stan\n# alpha * sqrt(sqrt(2*pi()) * rho) * exp(-0.25*(rho*pi()/2/L)^2 * linspaced_vector(M, 1, M)^2)\nfunction sds(what::HSGP, parameters) \n  sd, lengthscale = exp.(parameters[1:2])\n  sd .* sqrt.(sqrt(2pi*lengthscale) .* exp.(-(lengthscale*pi/4/what.L)^2 .* what.indices))\nend\nlog_sds(what::HSGP, parameters) = log.(sds(what, parameters))\nx1s(what::HSGP, parameters) = parameters[3:end]\nfunction Distributions.logpdf(what::HSGP, parameters) \n  log_sd, log_lengthscale = parameters[1:2]\n  sd, lengthscale = exp.([log_sd, log_lengthscale])\n  sum(\n    logpdf.(Normal(), [log_sd, log_lengthscale])\n  ) + sum(\n    logpdf.(Normal.(0, sds(what, parameters).^-what.centeredness_remaining), parameters[3:end])\n  )\nend\nfunction Base.rand(what::HSGP)\n  xis = randn(what.no_dimensions)\n  log_sd, log_lengthscale = xis[1:2]\n  return vcat(log_sd, log_lengthscale, sds(what, parameters).^-what.centeredness_remaining .* xis[3:end])\nend\n\nshowcase(NealsFunnel(rand(5)), :parametrization)"
  },
  {
    "objectID": "posteriordb_independent.html",
    "href": "posteriordb_independent.html",
    "title": "Using posteriordb reference draws",
    "section": "",
    "text": "if pwd()[end] != 's'\n    using Revise\n    using Pkg\n    cd(\"examples\")\n    Pkg.activate(\".\")\n    # Base.display(d::VSCodeServer.InlineDisplay, what::Plot) = display(d, what.figure)\nend\nincludet(\"common.jl\")\nRandom.seed!(1) \nes_posterior = PDBPosterior(\n    \"eight_schools-eight_schools_centered\", distribution_info_wrapper=EightSchoolsInfo\n)\n# es_posterior = PDBPosterior(\n#     \"mcycle_gp-accel_gp\", distribution_info_wrapper=MotorcycleInfo\n# )\nes_draws_full = es_posterior.unconstrained_draws\nbc = es_draws_full.best_centeredness\ncs = range(0, 1, 21)\nfcs = [\n    fill(c, size(bc)) for c in cs \n    # replace_xcs(bc, [i], [c])\n    # for c in cs, i in 1:length(bc)\n]\nes_draws = subset(es_draws_full, 1:20)\nces_draws = DynamicObjects.update(es_draws, :gradients, :log_sds) \nslosses = hcat(scalar_losses.([es_draws], fcs)...)'\n# flosses = hcat(fisher_scalar_losses.([ces_draws], fcs)...)'\nglosses = hcat(gradient_losses.([ces_draws], fcs)...)' \n# fglosses = hcat(fisher_gradient_losses.([ces_draws], fcs)...)'\nwlosses = hcat(wasserstein_losses.([es_draws], fcs)...)'\nclosses = hcat(cdf_losses.([es_draws], fcs)...)'\nsbc = cs[argmin.(eachcol(slosses))]\ngbc = cs[argmin.(eachcol(glosses))]\n# fgbc = cs[argmin.(eachcol(fglosses))] \nwbc = cs[argmin.(eachcol(wlosses))] \nlossess = [slosses, log.(glosses), wlosses, closses]\nplot([plot(losses) for losses in lossess]..., label=\"\")\n# # gradient_update(es_draws, bc).gradients - xcs_gradient_update(ces_draws, bc).gradients\n# # sum([\n# #     Scatter(bc, (cs[argmin.(eachcol(losses))]), plot_kwargs=(label=i, alpha=.5))\n# #     for (i, losses) in enumerate(lossess)\n# # ]).figure\n# sum([\n#     Line(sort(cs[argmin.(eachcol(losses))]), 1:length(bc), plot_kwargs=(label=i, ))\n#     for (i, losses) in enumerate(lossess)\n# ], init=Line(sort(bc), 1:length(bc))).figure\n\n# plot_x(x, y) = scatter!(plot(cs, y), cs[argmin.(y)], minimum.(y), color=:red)\n# plot([\n#     scatter!(plot_x(cs, to_unit_range.(eachcol(losses))), bc, ones(length(bc)), color=\"black\")\n#     # scatter(bc, cs[argmin.(eachcol(losses))])\n#     for losses in lossess\n# ]..., label=\"\", size=(800, 800), xlim=[0,1], ylim=[0,1])\n\n\n# heatmap_x(x, y, M) = scatter!(heatmap(x, y, M), y[argmin(M)[2]:argmin(M)[2]], x[argmin(M)[1]:argmin(M)[1]], color=:white, label=\"\")\n# plot([\n#     scatter!(heatmap_x(cs, cs, losses), bc[2:2], bc[1:1]) \n#     for losses in [slosses, flosses, glosses, fglosses]\n# ]..., layout=(2, :), size=(800, 800))\n# plot(cs, to_unit_range.([slosses, glosses]))\n# gradient_loss(es_draws, ones(8))\n# gradient_loss(es_draws, zeros(8))\n# PairPlots(es_draws)\n# @time es_bc = es_draws.best_centeredness\n# UnconstrainedDraws(\n#     EightSchoolsInfo(Dict(\"J\"=&gt;8)), \n#     PDBPosterior(\"eight_schools-eight_schools_centered\").unconstrained_draws\n# )\n# es_draws = EightSchoolsDraws(PDBPosterior(\"eight_schools-eight_schools_centered\").unconstrained_draws)\n\n# nc_es_draws = reparametrize(ContinuousNoncentering(zeros(8)), es_draws)\n\nmxcs_idxs = es_draws_full.info.xcs_idxs\nes_draws = subset(es_draws_full, 1:1000) \n# es_draws = es_draws_full#subset(es_draws_full, 1000) \n\nupdate_losses(what, c) = DynamicObjects.update(\n    DynamicObjects.update(recenter(what, c), :gradients),\n    :all_gradient_losses, :all_fisher_gradient_losses\n)\n\nces_draws = update_losses(es_draws, 1)\nbc_es_draws = update_losses(es_draws, bc)\nsbc_es_draws = update_losses(es_draws, sbc)\ngbc_es_draws = update_losses(es_draws, gbc)\nfgbc_es_draws = update_losses(es_draws, fgbc)\nbc_draws = [ces_draws, bc_es_draws, sbc_es_draws, gbc_es_draws, fgbc_es_draws]\n\n\n\n# Base.show(io::IO, mime::MIME{Symbol(\"application/vnd.julia-vscode.diagnostics\")}, what::Plot) = (\n#     println(typeof.([io, mime, what]));\n#     Base.show(io, mime, what.figure)\n# ) \nsum([\n    PairPlots(es_draws), \n    PairPlots(bc_es_draws)', \n]) |&gt; display  \nsum([\n    PairPlots(es_draws.pcad), \n    # PairPlots(bc_es_draws.pcad)', \n    PairPlots(es_draws.whitened)', \n]) |&gt; display  \nsum([\n    PairPlots(es_draws.descaled.pcad), \n    # PairPlots(bc_es_draws.pcad)', \n    PairPlots(es_draws.descaled.whitened)', \n]) |&gt; display  \n\n# @dynamic_object DUMMY test::Integer\n# Base.show(what::DUMMY) = show(stdout, what)\n# Base.show(io::IO, what::DUMMY) = show(io, typeof.([io, what]))\n# Base.show(io::IO, mime::MIME, what::DUMMY) = show(io, mime, typeof.([io, mime, what]))\n# DUMMY(1) |&gt; show \n\nmins = log.([\n    minimum(vcat([draws.all_gradient_losses[:, mxcs_idxs[i]] for draws in bc_draws]...))\n    for i in 1:es_draws.info.no_xcs\n])\nmaxs = log.([\n    maximum(vcat([draws.all_gradient_losses[:, mxcs_idxs[i]] for draws in bc_draws]...))\n    for i in 1:es_draws.info.no_xcs\n]) \n\nscatter(bc_es_draws[:, mxcs_idxs[1]], bc_es_draws.gradients[:, mxcs_idxs[1]], alpha=.5)\n\nmno_xcs = es_draws.info.no_xcs \nagl_idxs = sortperm.(eachcol(ces_draws.all_gradient_losses[:, mxcs_idxs]))\n\nFigure([ \n    !ismissing(draws) ? (\n        scatter_funnel(\n            draws, i, log.(draws.all_gradient_losses[:, mxcs_idxs[i]]),\n            clim=(mins[i], maxs[i])\n        ) \n        # SortedScatter(\n        #     draws[:, mxcs_idxs[i]], draws.gradients[:, mxcs_idxs[i]], \n        #     log.(draws.all_gradient_losses[:, mxcs_idxs[i]]),\n        #     clim=(mins[i], maxs[i]) \n        # )\n    )  : sum([\n        Line(\n            sort(draws.all_gradient_losses[:, mxcs_idxs[i]]), \n            reverse(1:size(es_draws, 1)),\n            # draws.all_gradient_losses[agl_idxs[i], mxcs_idxs[i]],\n            plot_kwargs=(label=j, xaxis=:log)# xaxis=:log, yaxis=:log)\n        )\n        # Line(sort((draws.all_gradient_losses[:, mxcs_idxs[i]])), 1:size(es_draws, 1))\n        for (j, draws) in enumerate(bc_draws)\n    ])\n    for i in 1:mno_xcs, draws in vcat(bc_draws, missing)\n], plot_width=200, extra_figure_kwargs=(\n    margin=0mm,\n    xaxis=false, yaxis=false, xticks=false, yticks=false, \n)) |&gt; display\n\nFigure([ \n    !ismissing(draws) ? (\n        # scatter_funnel(\n        #     draws, i, log.(draws.all_gradient_losses[:, mxcs_idxs[i]]),\n        #     clim=(mins[i], maxs[i])#, colorbar=draws === bc_draws[1] ? :left : :none\n        # ) \n        SortedScatter(\n            draws[:, mxcs_idxs[i]], draws.gradients[:, mxcs_idxs[i]], \n            log.(draws.all_gradient_losses[:, mxcs_idxs[i]]),\n            clim=(mins[i], maxs[i]) \n        )\n    )  : sum([\n        Line(\n            sort(draws.all_gradient_losses[:, mxcs_idxs[i]]), \n            reverse(1:size(es_draws, 1)),\n            # draws.all_gradient_losses[agl_idxs[i], mxcs_idxs[i]],\n            plot_kwargs=(label=j, xaxis=:log)# xaxis=:log, yaxis=:log)\n        )\n        # Line(sort((draws.all_gradient_losses[:, mxcs_idxs[i]])), 1:size(es_draws, 1))\n        for (j, draws) in enumerate(bc_draws)\n    ])\n    for i in 1:mno_xcs, draws in vcat(bc_draws, missing)\n], plot_width=200, extra_figure_kwargs=(\n    margin=0mm,\n    xaxis=false, yaxis=false, xticks=false, yticks=false, \n))\n \n\n# Figure([ \n#     scatter_funnel(draws, i, log.(draws.all_fisher_gradient_losses[:, mxcs_idxs[i]]))\n#     for i in 1:es_draws.info.no_xcs, draws in bc_draws\n# ], plot_width=200, extra_figure_kwargs=(\n#     margin=0mm,\n#     xaxis=false, yaxis=false, xticks=false, yticks=false, \n# ))  \n# mc_posterior = PDBPosterior(\n#     \"mcycle_gp-accel_gp\", distribution_info_wrapper=MotorcycleInfo\n# )\n# mc_draws = mc_posterior.unconstrained_draws\n# bc_mc_draws = reparametrize(ContinuousNoncentering(mc_draws.best_centeredness, 0), mc_draws)\n# Figure([ \n#     scatter_funnel(draws, i)\n#     for i in 1:mc_draws.info.no_xcs, draws in [mc_draws, bc_mc_draws]\n# ], plot_width=200, extra_figure_kwargs=(\n#     margin=0mm,\n#     xaxis=false, yaxis=false, xticks=false, yticks=false, \n#     markerstrokewidth=0,\n# ))\n# # @time mc_draws.best_centeredness\n# plot(\n#     [mc_draws.best_centeredness, best_centeredness(mc_draws, naive_loss)],\n# )\n# update_data(mc_posterior, Dict(\"NBgp_1\"=&gt;1)).data_string\n# mc_draws = mc_posterior.unconstrained_draws\n# # c_pu = ContinuousNoncentering(ones(mc_draws.no_xcs), previous_centeredness=0) \n# # c_mc_draws = reparametrize(c_pu, mc_draws)\n# # bc_mc_pu = ContinuousNoncentering(mc_draws.best_centeredness, motorcycle_wrapper, previous_centeredness=0)\n# # bc_mc_draws = reparametrize(bc_mc_pu, mc_draws)\n# # display(Line(1:mc_draws.no_xcs, bc_mc_pu.centeredness))\n# # plot(mc_draws.best_centeredness)\n# bc = mc_draws.best_centeredness\n# bc_mc_draws = subset(\n#     reparametrize(\n#         ContinuousNoncentering(\n#             bc, motorcycle_wrapper, previous_centeredness=0\n#         ), \n#         mc_draws\n#     ), \n#     1:1000\n# )\n\n# # mc_draws = MotorcycleDraws(PDBPosterior(\"mcycle_gp-accel_gp\").unconstrained_draws)[1:1000, 1:60]\n# # no_plots = 40\n# PairPlots(subset(mc_draws, 1:1000), 1:20, 1:66)\n# ```   \n# ```{.julia}\n# PairPlots(mc_draws, 21:40, 21:66)\n# ``` \n# ```{.julia}\n# PairPlots(mc_draws, 41:66, 41:66)\n# ``` \n# ```{.julia}\n# idxs = vcat(2:4, 45:47)\n# PairPlots(bc_mc_draws, idxs, idxs)\n# ```\n# ```{.julia}\n# PairPlots(mc_draws, idxs, idxs)\n# ``` \n# ```{.julia}\n# cov_sqrt(what::UnconstrainedDraws) = sqrt(cov(what.unconstrained_draws))\n# pca_sqrt(what::UnconstrainedDraws) = (\n#     e = eigen(cov(what.unconstrained_draws));\n#     e.vectors * Diagonal(sqrt.(e.values))\n# )\n# Statistics.mean(what::UnconstrainedDraws) = mean(what.unconstrained_draws, dims=1)\n# whitened(what::UnconstrainedDraws) = DynamicObjects.update(\n#     what, unconstrained_draws=(\n#         what.unconstrained_draws .- what.mean\n#     ) / what.cov_sqrt' \n# )\n# pcad(what::UnconstrainedDraws) = DynamicObjects.update(\n#     what, unconstrained_draws=(\n#         what.unconstrained_draws .- what.mean\n#     ) / what.pca_sqrt' \n# ) \n# PairPlots(mc_draws.whitened, 1:20, 1:66)\n# # mc_draws.unconstrained_draws .- reshape(mc_draws.mean, (1, :))\n# # Statistics.cov(what::UnconstrainedDraws) = cov(what.unconstrained_draws)\n# # corr(what) = (\n# #     C = cov(what);\n# #     S = Diagonal(sqrt.(diag(C)));\n# #     S \\ C / S\n# # )\n\n# # square(x) = x^2\n# # argsort(x; kwargs...) = sort(1:length(x), by=i-&gt;x[i]; kwargs...)\n# # reverse(argsort(\n# #     maximum(abs.(eigen(cov(mc_draws.unconstrained_draws)).vectors), dims=2)\n# # ))'\n# ```  \n# ```{.julia}\n# # PairPlots(mc_draws.pcad, 1:20, 1:20)\n# PairPlots(mc_draws.pcad, 1:20, 1:66)\n# # reverse(argsort(\n# #     maximum(abs.(eigen(corr(mc_draws.unconstrained_draws)).vectors), dims=2)\n# # ))'\n# ``` \n# ```{.julia}"
  },
  {
    "objectID": "binom.html",
    "href": "binom.html",
    "title": "Using posteriordb reference draws",
    "section": "",
    "text": "if pwd()[end] != 's'\n    using Revise\n    using Pkg\n    cd(\"examples\")\n    Pkg.activate(\".\")\n    # Base.display(d::VSCodeServer.InlineDisplay, what::Plot) = display(d, what.figure)\nend\nincludet(\"common.jl\")\nRandom.seed!(1) \n\nTaskLocalRNG()\n\n\n\n\"\"\"\nparameters {\n    real mu;                                                // population mean of success log-odds\n    real&lt;lower=0&gt; sigma;                                    // population sd of success log-odds\n    vector[n_opponents] alpha;                              // success log-odds\n}\n\"\"\"\n@dynamic_object BinomInfo &lt;: DistributionInfo data::Dict\nxcs_idxs(what::BinomInfo) = 3:2+what[\"n_opponents\"]\nmeans_idxs(what::BinomInfo) = 1\nlog_sds_idxs(what::BinomInfo) = 2\ncenteredness(what::BinomInfo) = 1\n\nbinom_dist(data_path) = (\n    json_string = read(open(data_path, \"r\"), String);\n    BSDistribution(StanModel(\n        stan_file=\"binom/model.stan\", \n        data=json_string\n    ), info=BinomInfo(JSON.parse(json_string)))\n)\n\nfunction nbc_draws(dist)\n    no_xcs = length(dist.info.xcs_idxs)\n    nc_draws = recenter(dist, zeros(no_xcs)).cached_unconstrained_chains\n    bc_draws = recenter(dist, nc_draws.best_centeredness).cached_unconstrained_chains\n    c_draws = recenter(dist, ones(no_xcs)).cached_unconstrained_chains\n\n    [nc_draws, bc_draws, c_draws] .|&gt; (draws-&gt;recenter(draws, 1) |&gt; update(:effs))\nend\n\nfunction effs_plot(dist, rel=false, means=true)\n    parameter_idxs = 1:dist.no_dimensions\n    nbc_draws = dist.cached_nbc_draws \n    effs = getproperty.(nbc_draws, means ? :effs : :sq_effs)\n    sort_idxs = sortperm(vec(minimum(hcat(effs...), dims=2)))\n    effs = [eff[sort_idxs] for eff in effs]\n    if rel\n        effs = [eff ./ effs[2] for eff in effs]\n        Line(\n            parameter_idxs, effs, \n            plot_kwargs=(ylim=(0, Inf), \n            label=[\"non-centered\" \"adaptive\" \"centered\"], color=[:blue :red :green])\n        )\n    else\n        Line(\n            parameter_idxs, effs, \n            plot_kwargs=(ylim=(0, Inf), label=[\"non-centered\" \"adaptive\"  \"centered\"])\n        )\n    end\nend \nsq_effs_plot(dist) = effs_plot(dist, false, false)\nrel_effs_plot(dist) = effs_plot(dist, true)\nrel_sq_effs_plot(dist) = effs_plot(dist, true, false)\n\nfunction means_plot(dist)\n    parameter_idxs = 1:dist.no_dimensions\n    nbc_draws = dist.cached_nbc_draws \n    means = mean.(nbc_draws, dims=1)\n    stds = std.(nbc_draws, dims=1)\n    rel_means = [(mean .- means[2])./stds[2] for mean in means][[1,3]]\n    rel_stds = [std./stds[2] for std in stds][[1,3]]\n    colors = [:blue, :green]\n    sum([\n        (\n            Scatter([i], [rel_means[i]], plot_kwargs=(label=\"\", color=color)) \n            + Line([i,i], rel_means[i] .+ [-1, +1] .* rel_stds[i], plot_kwargs=(label=\"\", color=color))\n        )\n        for (color, rel_means, rel_stds) in zip(colors, rel_means, rel_stds)\n        for i in parameter_idxs\n    ])\nend\n\nsummary_plot(dist) = Figure([\n    effs_plot(dist, rel, means)\n    for rel in [false, true], means in [true, false]\n    # dist.effs_plot, dist.rel_effs_plot, dist.means_plot\n])\nfunction convergence_plot(dist)\n    nbc_draws = dist.cached_nbc_draws\n    colors = [:blue, :red, :green]\n    sum([\n        Line(\n            cumsum(getproperty.(chain.all_stats, :n_steps))[1001:end],\n            global_convergence(dist, chain),\n            plot_kwargs=(label=\"\", color=color)\n        )\n        for (color, draws) in zip(colors, nbc_draws)\n        for chain in draws.chains\n    ]) |&gt; update(\n        plot_kwargs=(xlim=(0, Inf), ylim=(-Inf, 1), yaxis=:log)\n    )\nend\nshow_plots(dist) = display.([dist.cached_convergence_plot|&gt; update(\n        plot_kwargs=(xlim=(0, Inf), ylim=(0, 1))\n    ), dist.cached_summary_plot])\n\nbinom_dist(\"binom/data.json\").cached_convergence_plot |&gt; update(\n    plot_kwargs=(xlim=(0, Inf), ylim=(-Inf, 1), yaxis=:log)\n)\n# binom_dist(\"binom/data.json\").cached_summary_plot\n# plot(\n#     [\n#         cumsum(getproperty.(chain.all_stats, :n_steps))[1001:end]\n#         for draws in binom_dist(\"binom/data.json\").cached_nbc_draws\n#         for chain in draws.chains\n#     ],\n#     [\n#         update(chain, reference_distribution=binom_dist(\"binom/data.json\")).global_convergence\n#         for draws in binom_dist(\"binom/data.json\").cached_nbc_draws\n#         for chain in draws.chains\n#     ],\n#     xaxis=:linear, yaxis=:log, ylim=[1e-4, 1],\n#     label=\"\", color=hcat(fill(:red, (1, 4)), fill(:blue, (1, 4)))\n# )\n# convergence_plot(binom_dist(\"binom/data.json\"), binom_dist(\"binom/data.json\").cached_unconstrained_draws)\n# convergence_plot(binom_dist(\"binom/data.json\").cached_nbc_draws[1])\n# binom_dist(\"binom/data.json\").cached_nbc_draws[1].esss\n# binom_dist(\"binom/data.json\").cached_reference_chains.esss\n# nc_draws, bc_draws, c_draws = dist.nbc_draws\n# bc_draws = recenter(draws)\n# nc_draws = recenter(dist, zeros(size(bc_draws.centeredness))).cached_unconstrained_chains\n# bc_redraws = bc_draws.distribution.cached_unconstrained_chains\n\n# (\n#     PairPlots(recenter(nc_draws, 1), 1:10)\n#     + PairPlots(recenter(bc_redraws, 1), 1:10)\n#     + PairPlots(draws, 1:10) \n#     # + PairPlots(recenter(draws, 0), 1:10)' \n#     # + PairPlots(recenter(bc_redraws, 0), 1:10)' \n# )\n\n# CenterednessComparison([nc_draws, bc_draws, c_draws])\n \n# Scatter(draws[:, 1], draws[:, 2]).figure\n# bc_draws = recenter(draws)\n# bc_dist = InfoDistribution(bc_draws.info)\n# logpdf(bc_dist, bc_draws[1,:])\n\n# logpdf(bc_draws.info.distribution, bc_draws.info, bc_draws[1,:])\n# logpdf_gradient(bc_info, bc_draws[1, :])\n# bc_redraws = DynamicObjects.update(\n#     DynamicObjects.cached(bc_dist, :unconstrained_draws),\n#     info=bc_draws.info\n# )\n# scatter(draws.best_centeredness, [\n#     nc_draws.best_centeredness,\n#     bc_draws.best_centeredness,\n#     draws.best_centeredness\n# ])\n\n┌ Warning: Loading a shared object '/home/niko/github/WarmupHMC.jl/examples/binom/model_model.so' which is already loaded.\n│ If the file has changed since the last time it was loaded, this load may not update the library!\n└ @ BridgeStan ~/.julia/packages/BridgeStan/nCPwJ/src/model.jl:51\n\n\n\n\n\n\nbinom_dist(\"binom/data2.json\") |&gt; show_plots;\n\n┌ Warning: Loading a shared object '/home/niko/github/WarmupHMC.jl/examples/binom/model_model.so' which is already loaded.\n│ If the file has changed since the last time it was loaded, this load may not update the library!\n└ @ BridgeStan ~/.julia/packages/BridgeStan/nCPwJ/src/model.jl:51\n\n\n\n\n\nSaving figs/7744809079314092434.png.\n\n\n\n\n\n\nPDBPosterior(\n    \"eight_schools-eight_schools_centered\", info_wrapper=EightSchoolsInfo\n).bridgestan_distribution |&gt; show_plots;\n\n┌ Warning: Loading a shared object '/home/niko/.julia/artifacts/95c3074bd791a2f28857088639b48ca1b786459a/posteriordb-0.4.0/posterior_database/models/stan/eight_schools_centered_model.so' which is already loaded.\n│ If the file has changed since the last time it was loaded, this load may not update the library!\n└ @ BridgeStan ~/.julia/packages/BridgeStan/nCPwJ/src/model.jl:51\n\n\n\n\n\nSaving figs/2224432746296052992.png.\n\n\n\n\n\n\nPDBPosterior(\n    \"radon_mn-radon_hierarchical_intercept_centered\", info_wrapper=RadonICInfo\n).bridgestan_distribution |&gt; show_plots;\n\n┌ Warning: Loading a shared object '/home/niko/.julia/artifacts/95c3074bd791a2f28857088639b48ca1b786459a/posteriordb-0.4.0/posterior_database/models/stan/radon_hierarchical_intercept_centered_model.so' which is already loaded.\n│ If the file has changed since the last time it was loaded, this load may not update the library!\n└ @ BridgeStan ~/.julia/packages/BridgeStan/nCPwJ/src/model.jl:51\n\n\n\n\n\nSaving figs/18326102585252186024.png.\n\n\n\n\n\n\nPDBPosterior(\n    \"radon_mn-radon_variable_intercept_slope_centered\", info_wrapper=RadonISCInfo\n).bridgestan_distribution |&gt; show_plots;\n\n┌ Warning: Loading a shared object '/home/niko/.julia/artifacts/95c3074bd791a2f28857088639b48ca1b786459a/posteriordb-0.4.0/posterior_database/models/stan/radon_variable_intercept_slope_centered_model.so' which is already loaded.\n│ If the file has changed since the last time it was loaded, this load may not update the library!\n└ @ BridgeStan ~/.julia/packages/BridgeStan/nCPwJ/src/model.jl:51\n\n\n\n\n\nSaving figs/5533663516827080904.png.\n\n\n\n\n\nPDBPosterior(\n    \"radon_all-radon_hierarchical_intercept_centered\", info_wrapper=RadonICInfo\n).bridgestan_distribution |&gt; show_plots;\nPDBPosterior(\n    \"radon_all-radon_variable_intercept_slope_centered\", info_wrapper=RadonISCInfo\n).bridgestan_distribution |&gt; show_plots;\n\nPairPlots(\n    mcycle_dist(\"homoscedastic\").cached_unconstrained_draws, 1:20\n) + PairPlots(\n    recenter(mcycle_dist(\"homoscedastic_centered\").cached_unconstrained_draws, 0), 1:20\n)\nmcycle_dist(\"homoscedastic_centered\") |&gt; show_plots;\n\n┌ Warning: Loading a shared object '/home/niko/github/WarmupHMC.jl/examples/mcycle/homoscedastic_model.so' which is already loaded.\n│ If the file has changed since the last time it was loaded, this load may not update the library!\n└ @ BridgeStan ~/.julia/packages/BridgeStan/nCPwJ/src/model.jl:51\n┌ Warning: Loading a shared object '/home/niko/github/WarmupHMC.jl/examples/mcycle/homoscedastic_centered_model.so' which is already loaded.\n│ If the file has changed since the last time it was loaded, this load may not update the library!\n└ @ BridgeStan ~/.julia/packages/BridgeStan/nCPwJ/src/model.jl:51\n┌ Warning: Loading a shared object '/home/niko/github/WarmupHMC.jl/examples/mcycle/homoscedastic_centered_model.so' which is already loaded.\n│ If the file has changed since the last time it was loaded, this load may not update the library!\n└ @ BridgeStan ~/.julia/packages/BridgeStan/nCPwJ/src/model.jl:51\n\n\n\n\n\nSaving figs/8682276540219863466.png."
  }
]