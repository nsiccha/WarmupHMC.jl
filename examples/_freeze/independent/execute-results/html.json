{
  "hash": "c264e9ce76868b162783216500c3b107",
  "result": {
    "markdown": "---\ntitle: Using independent draws\nexecute:\n  daemon: 999999\n---\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nusing DynamicObjects, WarmupHMC\nusing Distributions, Statistics, LinearAlgebra, ForwardDiff\nusing Plots\n\n@dynamic_object WarmupWindow no_iterations::Integer type\n \n@dynamic_object StanWarmup no_iterations::Number adaptation=:metric\nwarmup_windows(what::StanWarmup) = [\n  WarmupWindow(75, :scale)\n  WarmupWindow(25, what.adaptation)\n  WarmupWindow(50, what.adaptation)\n  WarmupWindow(100, what.adaptation)\n  WarmupWindow(200, what.adaptation)\n  WarmupWindow(500, what.adaptation)\n  WarmupWindow(50, :scale)\n]\n\nDistributions.logpdf(what::DynamicObject, parameters) = logpdf(what.distribution, parameters)\nno_dimensions(what::DynamicObject) = length(what.distribution)\nlogpdf_gradient(what::DynamicObject, parameters) = ForwardDiff.gradient(\n  theta->logpdf(what, theta), parameters\n)\n\n@dynamic_object IndependentKernel distribution::Distribution\n@dynamic_object IndependentKernel distribution::DynamicObject\ntransition(what::IndependentKernel, last) = rand(what.distribution)\n\n@dynamic_object Warmup kernel procedure\n# no_dimensions(what::Warmup) = length(what.kernel.distribution)\nwarmup_windows(what::Warmup) = what.procedure.warmup_windows\ncovariance(what::DynamicObject) = cov(what.distribution)\ncovariance_estimate(what::DynamicObject) = LinearAlgebra.I \nfunction covariance_remaining(what::DynamicObject)\n  ce = what.covariance_estimate\n  L = isa(ce, UniformScaling) ? I : cholesky(ce).L\n  return L \\ what.covariance / L'\nend\nfunction kernels(what::Warmup)\n  current_kernel = what.kernel\n  rv = [current_kernel]\n  fig = missing\n\n  no_dimensions = current_kernel.no_dimensions\n  current_parameters = zeros(no_dimensions)\n\n  for window in what.warmup_windows\n    samples = zeros((window.no_iterations, no_dimensions))\n    gradients = zeros((window.no_iterations, no_dimensions))\n    for iteration in 1:window.no_iterations\n      current_parameters .= transition(current_kernel, current_parameters)\n      samples[iteration, :] .= current_parameters\n      gradients[iteration, :] .= logpdf_gradient(current_kernel, current_parameters)\n    end\n    scov = cov(samples)\n    gcov = cov(gradients)\n    if window.type == :metric\n      # covariance_estimate = regularize(Symmetric(scov), window.no_iterations)\n      covariance_estimate = regularize(Diagonal(sqrt.(diag(scov) ./ diag(gcov))), window.no_iterations)\n      current_kernel = DynamicObjects.update(\n        current_kernel, covariance_estimate=covariance_estimate\n      )\n      push!(rv, current_kernel)\n    end\n    if window.type == :parametrization\n      ismissing(fig) && (fig = vline(current_kernel.distribution.centeredness[1:1], ylim=[0,1]))\n      # klps_plot!(\n      #   fig, \n      #   [x1s(current_kernel.distribution, parameters)[1] for parameters in eachrow(samples)],\n      #   [log_sds(current_kernel.distribution, parameters)[1] for parameters in eachrow(samples)]\n      # )\n      # cs = LinRange(0, 1, 100)\n      # x1 = [x1s(current_kernel.distribution, parameters)[1] for parameters in eachrow(samples)]\n      # sd = [sds(current_kernel.distribution, parameters)[1] for parameters in eachrow(samples)]\n      # # x1, sd = samples[:, 2], samples[:, 1]\n      # kl1s = [klp(x1, log.(sd), c) for c in cs]\n      # kl1s .-= minimum(kl1s)\n      # kl1s ./= maximum(kl1s)\n      # plot!(fig, cs, kl1s)\n      push!(rv, current_kernel)\n    end\n  end\n  !ismissing(fig) && display(fig)\n  return rv\nend\n\nshowcase(no_dimensions::Integer=10) = showcase(\n  MvNormal(randn(no_dimensions), Diagonal(exp.(randn(no_dimensions))))\n)\nfunction showcase(distribution, adaptation=:metric)\n  sw = StanWarmup(1000, adaptation)\n  ikernels = Warmup(IndependentKernel(distribution), sw).kernels\n  iconds = cond.(covariance_remaining.(ikernels))\n  conds = iconds\n  plot(\n    [iconds], yaxis=:log, ylim=[1, maximum(conds)], marker=:circle\n  )\nend\nshowcase()\n```\n\n::: {.cell-output .cell-output-display execution_count=10}\n![](independent_files/figure-html/cell-2-output-1.svg){}\n:::\n:::\n\n\n::: {.cell execution_count=2}\n``` {.julia .cell-code}\n\"\"\"\nNeal's funnel with a twist!\n\"\"\"\n@dynamic_object NealsFunnel centeredness::Vector\nno_dimensions(what::NealsFunnel) = 1+length(what.centeredness)\nBase.length(what::NealsFunnel) = what.no_dimensions\ncenteredness_estimate(what::NealsFunnel) = ones(length(what.centeredness))\ncenteredness_remaining(what::NealsFunnel) = what.centeredness - what.centeredness_estimate\nStatistics.cov(what::NealsFunnel) = LinearAlgebra.I\nlog_sds(what::NealsFunnel, parameters) = exp(parameters[1])\nx1s(what::NealsFunnel, parameters) = parameters[2:end]\nfunction Distributions.logpdf(what::NealsFunnel, parameters) \n  log_sd = parameters[1]\n  sd = exp(log_sd)\n  logpdf(Normal(), log_sd) + sum(logpdf.(Normal.(0, sd.^-what.centeredness_remaining), parameters[2:end]))\nend\nfunction Base.rand(what::NealsFunnel)\n  xis = randn(what.no_dimensions)\n  log_sd = xis[1]\n  sd = exp(log_sd)\n  return vcat(log_sd, sd.^-what.centeredness_remaining .* xis[2:end])\nend\n\nshowcase(NealsFunnel(rand(5)), :parametrization)\n```\n\n::: {.cell-output .cell-output-display}\n![](independent_files/figure-html/cell-3-output-1.svg){}\n:::\n\n::: {.cell-output .cell-output-display execution_count=11}\n![](independent_files/figure-html/cell-3-output-2.svg){}\n:::\n:::\n\n\n::: {.cell execution_count=3}\n``` {.julia .cell-code}\n\"\"\"\nA distribution which looks a bit like an HSGP posterior!\n\"\"\"\n@dynamic_object HSGP centeredness::Vector L=1.5\nno_basis_functions(what::HSGP) = length(what.centeredness)\nindices(what::HSGP) = 1:what.no_basis_functions\nno_dimensions(what::HSGP) = 2+what.no_basis_functions\nBase.length(what::HSGP) = what.no_dimensions\ncenteredness_estimate(what::HSGP) = ones(what.no_basis_functions)\ncenteredness_remaining(what::HSGP) = what.centeredness - what.centeredness_estimate\nStatistics.cov(what::HSGP) = LinearAlgebra.I\n# https://github.com/avehtari/casestudies/blob/master/Birthdays/gpbasisfun_functions.stan\n# alpha * sqrt(sqrt(2*pi()) * rho) * exp(-0.25*(rho*pi()/2/L)^2 * linspaced_vector(M, 1, M)^2)\nfunction sds(what::HSGP, parameters) \n  sd, lengthscale = exp.(parameters[1:2])\n  sd .* sqrt.(sqrt(2pi*lengthscale) .* exp.(-(lengthscale*pi/4/what.L)^2 .* what.indices))\nend\nlog_sds(what::HSGP, parameters) = log.(sds(what, parameters))\nx1s(what::HSGP, parameters) = parameters[3:end]\nfunction Distributions.logpdf(what::HSGP, parameters) \n  log_sd, log_lengthscale = parameters[1:2]\n  sd, lengthscale = exp.([log_sd, log_lengthscale])\n  sum(\n    logpdf.(Normal(), [log_sd, log_lengthscale])\n  ) + sum(\n    logpdf.(Normal.(0, sds(what, parameters).^-what.centeredness_remaining), parameters[3:end])\n  )\nend\nfunction Base.rand(what::HSGP)\n  xis = randn(what.no_dimensions)\n  log_sd, log_lengthscale = xis[1:2]\n  return vcat(log_sd, log_lengthscale, sds(what, parameters).^-what.centeredness_remaining .* xis[3:end])\nend\n\nshowcase(NealsFunnel(rand(5)), :parametrization)  \n```\n\n::: {.cell-output .cell-output-display}\n![](independent_files/figure-html/cell-4-output-1.svg){}\n:::\n\n::: {.cell-output .cell-output-display execution_count=12}\n![](independent_files/figure-html/cell-4-output-2.svg){}\n:::\n:::\n\n\n",
    "supporting": [
      "independent_files/figure-html"
    ],
    "filters": [],
    "includes": {}
  }
}