{
  "hash": "27cfd835529dd4b7109ea8e1b9f28de2",
  "result": {
    "markdown": "---\ntitle: Using posteriordb reference draws\nexecute:\n  daemon: 999999\n---\n\n```{.julia}\nif pwd()[end] != 's'\n    using Revise\n    using Pkg\n    cd(\"examples\")\n    Pkg.activate(\".\")\n    # Base.display(d::VSCodeServer.InlineDisplay, what::Plot) = display(d, what.figure)\nend\nincludet(\"common.jl\")\nRandom.seed!(1) \n```\n```{.julia}\nes_posterior = PDBPosterior(\n    \"eight_schools-eight_schools_centered\", distribution_info_wrapper=EightSchoolsInfo\n)\n# es_posterior = PDBPosterior(\n#     \"mcycle_gp-accel_gp\", distribution_info_wrapper=MotorcycleInfo\n# )\nes_draws_full = es_posterior.unconstrained_draws\nbc = es_draws_full.best_centeredness\ncs = range(0, 1, 21)\nfcs = [\n    fill(c, size(bc)) for c in cs \n    # replace_xcs(bc, [i], [c])\n    # for c in cs, i in 1:length(bc)\n]\nes_draws = subset(es_draws_full, 1:20)\nces_draws = DynamicObjects.update(es_draws, :gradients, :log_sds) \nslosses = hcat(scalar_losses.([es_draws], fcs)...)'\n# flosses = hcat(fisher_scalar_losses.([ces_draws], fcs)...)'\nglosses = hcat(gradient_losses.([ces_draws], fcs)...)' \n# fglosses = hcat(fisher_gradient_losses.([ces_draws], fcs)...)'\nwlosses = hcat(wasserstein_losses.([es_draws], fcs)...)'\nclosses = hcat(cdf_losses.([es_draws], fcs)...)'\nsbc = cs[argmin.(eachcol(slosses))]\ngbc = cs[argmin.(eachcol(glosses))]\n# fgbc = cs[argmin.(eachcol(fglosses))] \nwbc = cs[argmin.(eachcol(wlosses))] \nlossess = [slosses, log.(glosses), wlosses, closses]\nplot([plot(losses) for losses in lossess]..., label=\"\")\n# # gradient_update(es_draws, bc).gradients - xcs_gradient_update(ces_draws, bc).gradients\n# # sum([\n# #     Scatter(bc, (cs[argmin.(eachcol(losses))]), plot_kwargs=(label=i, alpha=.5))\n# #     for (i, losses) in enumerate(lossess)\n# # ]).figure\n# sum([\n#     Line(sort(cs[argmin.(eachcol(losses))]), 1:length(bc), plot_kwargs=(label=i, ))\n#     for (i, losses) in enumerate(lossess)\n# ], init=Line(sort(bc), 1:length(bc))).figure\n\n# plot_x(x, y) = scatter!(plot(cs, y), cs[argmin.(y)], minimum.(y), color=:red)\n# plot([\n#     scatter!(plot_x(cs, to_unit_range.(eachcol(losses))), bc, ones(length(bc)), color=\"black\")\n#     # scatter(bc, cs[argmin.(eachcol(losses))])\n#     for losses in lossess\n# ]..., label=\"\", size=(800, 800), xlim=[0,1], ylim=[0,1])\n\n\n# heatmap_x(x, y, M) = scatter!(heatmap(x, y, M), y[argmin(M)[2]:argmin(M)[2]], x[argmin(M)[1]:argmin(M)[1]], color=:white, label=\"\")\n# plot([\n#     scatter!(heatmap_x(cs, cs, losses), bc[2:2], bc[1:1]) \n#     for losses in [slosses, flosses, glosses, fglosses]\n# ]..., layout=(2, :), size=(800, 800))\n# plot(cs, to_unit_range.([slosses, glosses]))\n# gradient_loss(es_draws, ones(8))\n# gradient_loss(es_draws, zeros(8))\n# PairPlots(es_draws)\n# @time es_bc = es_draws.best_centeredness\n# UnconstrainedDraws(\n#     EightSchoolsInfo(Dict(\"J\"=>8)), \n#     PDBPosterior(\"eight_schools-eight_schools_centered\").unconstrained_draws\n# )\n# es_draws = EightSchoolsDraws(PDBPosterior(\"eight_schools-eight_schools_centered\").unconstrained_draws)\n\n# nc_es_draws = reparametrize(ContinuousNoncentering(zeros(8)), es_draws)\n\nmxcs_idxs = es_draws_full.info.xcs_idxs\nes_draws = subset(es_draws_full, 1:1000) \n# es_draws = es_draws_full#subset(es_draws_full, 1000) \n\nupdate_losses(what, c) = DynamicObjects.update(\n    DynamicObjects.update(recenter(what, c), :gradients),\n    :all_gradient_losses, :all_fisher_gradient_losses\n)\n\nces_draws = update_losses(es_draws, 1)\nbc_es_draws = update_losses(es_draws, bc)\nsbc_es_draws = update_losses(es_draws, sbc)\ngbc_es_draws = update_losses(es_draws, gbc)\nfgbc_es_draws = update_losses(es_draws, fgbc)\nbc_draws = [ces_draws, bc_es_draws, sbc_es_draws, gbc_es_draws, fgbc_es_draws]\n\n\n\n# Base.show(io::IO, mime::MIME{Symbol(\"application/vnd.julia-vscode.diagnostics\")}, what::Plot) = (\n#     println(typeof.([io, mime, what]));\n#     Base.show(io, mime, what.figure)\n# ) \nsum([\n    PairPlots(es_draws), \n    PairPlots(bc_es_draws)', \n]) |> display  \nsum([\n    PairPlots(es_draws.pcad), \n    # PairPlots(bc_es_draws.pcad)', \n    PairPlots(es_draws.whitened)', \n]) |> display  \nsum([\n    PairPlots(es_draws.descaled.pcad), \n    # PairPlots(bc_es_draws.pcad)', \n    PairPlots(es_draws.descaled.whitened)', \n]) |> display  \n\n# @dynamic_object DUMMY test::Integer\n# Base.show(what::DUMMY) = show(stdout, what)\n# Base.show(io::IO, what::DUMMY) = show(io, typeof.([io, what]))\n# Base.show(io::IO, mime::MIME, what::DUMMY) = show(io, mime, typeof.([io, mime, what]))\n# DUMMY(1) |> show \n\nmins = log.([\n    minimum(vcat([draws.all_gradient_losses[:, mxcs_idxs[i]] for draws in bc_draws]...))\n    for i in 1:es_draws.info.no_xcs\n])\nmaxs = log.([\n    maximum(vcat([draws.all_gradient_losses[:, mxcs_idxs[i]] for draws in bc_draws]...))\n    for i in 1:es_draws.info.no_xcs\n]) \n\nscatter(bc_es_draws[:, mxcs_idxs[1]], bc_es_draws.gradients[:, mxcs_idxs[1]], alpha=.5)\n\nmno_xcs = es_draws.info.no_xcs \nagl_idxs = sortperm.(eachcol(ces_draws.all_gradient_losses[:, mxcs_idxs]))\n\nFigure([ \n    !ismissing(draws) ? (\n        scatter_funnel(\n            draws, i, log.(draws.all_gradient_losses[:, mxcs_idxs[i]]),\n            clim=(mins[i], maxs[i])\n        ) \n        # SortedScatter(\n        #     draws[:, mxcs_idxs[i]], draws.gradients[:, mxcs_idxs[i]], \n        #     log.(draws.all_gradient_losses[:, mxcs_idxs[i]]),\n        #     clim=(mins[i], maxs[i]) \n        # )\n    )  : sum([\n        Line(\n            sort(draws.all_gradient_losses[:, mxcs_idxs[i]]), \n            reverse(1:size(es_draws, 1)),\n            # draws.all_gradient_losses[agl_idxs[i], mxcs_idxs[i]],\n            plot_kwargs=(label=j, xaxis=:log)# xaxis=:log, yaxis=:log)\n        )\n        # Line(sort((draws.all_gradient_losses[:, mxcs_idxs[i]])), 1:size(es_draws, 1))\n        for (j, draws) in enumerate(bc_draws)\n    ])\n    for i in 1:mno_xcs, draws in vcat(bc_draws, missing)\n], plot_width=200, extra_figure_kwargs=(\n    margin=0mm,\n    xaxis=false, yaxis=false, xticks=false, yticks=false, \n)) |> display\n\nFigure([ \n    !ismissing(draws) ? (\n        # scatter_funnel(\n        #     draws, i, log.(draws.all_gradient_losses[:, mxcs_idxs[i]]),\n        #     clim=(mins[i], maxs[i])#, colorbar=draws === bc_draws[1] ? :left : :none\n        # ) \n        SortedScatter(\n            draws[:, mxcs_idxs[i]], draws.gradients[:, mxcs_idxs[i]], \n            log.(draws.all_gradient_losses[:, mxcs_idxs[i]]),\n            clim=(mins[i], maxs[i]) \n        )\n    )  : sum([\n        Line(\n            sort(draws.all_gradient_losses[:, mxcs_idxs[i]]), \n            reverse(1:size(es_draws, 1)),\n            # draws.all_gradient_losses[agl_idxs[i], mxcs_idxs[i]],\n            plot_kwargs=(label=j, xaxis=:log)# xaxis=:log, yaxis=:log)\n        )\n        # Line(sort((draws.all_gradient_losses[:, mxcs_idxs[i]])), 1:size(es_draws, 1))\n        for (j, draws) in enumerate(bc_draws)\n    ])\n    for i in 1:mno_xcs, draws in vcat(bc_draws, missing)\n], plot_width=200, extra_figure_kwargs=(\n    margin=0mm,\n    xaxis=false, yaxis=false, xticks=false, yticks=false, \n))\n \n\n# Figure([ \n#     scatter_funnel(draws, i, log.(draws.all_fisher_gradient_losses[:, mxcs_idxs[i]]))\n#     for i in 1:es_draws.info.no_xcs, draws in bc_draws\n# ], plot_width=200, extra_figure_kwargs=(\n#     margin=0mm,\n#     xaxis=false, yaxis=false, xticks=false, yticks=false, \n# ))  \n```   \n```{.julia}\n# mc_posterior = PDBPosterior(\n#     \"mcycle_gp-accel_gp\", distribution_info_wrapper=MotorcycleInfo\n# )\n# mc_draws = mc_posterior.unconstrained_draws\n# bc_mc_draws = reparametrize(ContinuousNoncentering(mc_draws.best_centeredness, 0), mc_draws)\n# Figure([ \n#     scatter_funnel(draws, i)\n#     for i in 1:mc_draws.info.no_xcs, draws in [mc_draws, bc_mc_draws]\n# ], plot_width=200, extra_figure_kwargs=(\n#     margin=0mm,\n#     xaxis=false, yaxis=false, xticks=false, yticks=false, \n#     markerstrokewidth=0,\n# ))\n# # @time mc_draws.best_centeredness\n# plot(\n#     [mc_draws.best_centeredness, best_centeredness(mc_draws, naive_loss)],\n# )\n# update_data(mc_posterior, Dict(\"NBgp_1\"=>1)).data_string\n# mc_draws = mc_posterior.unconstrained_draws\n# # c_pu = ContinuousNoncentering(ones(mc_draws.no_xcs), previous_centeredness=0) \n# # c_mc_draws = reparametrize(c_pu, mc_draws)\n# # bc_mc_pu = ContinuousNoncentering(mc_draws.best_centeredness, motorcycle_wrapper, previous_centeredness=0)\n# # bc_mc_draws = reparametrize(bc_mc_pu, mc_draws)\n# # display(Line(1:mc_draws.no_xcs, bc_mc_pu.centeredness))\n# # plot(mc_draws.best_centeredness)\n# bc = mc_draws.best_centeredness\n# bc_mc_draws = subset(\n#     reparametrize(\n#         ContinuousNoncentering(\n#             bc, motorcycle_wrapper, previous_centeredness=0\n#         ), \n#         mc_draws\n#     ), \n#     1:1000\n# )\n\n# # mc_draws = MotorcycleDraws(PDBPosterior(\"mcycle_gp-accel_gp\").unconstrained_draws)[1:1000, 1:60]\n# # no_plots = 40\n# PairPlots(subset(mc_draws, 1:1000), 1:20, 1:66)\n# ```   \n# ```{.julia}\n# PairPlots(mc_draws, 21:40, 21:66)\n# ``` \n# ```{.julia}\n# PairPlots(mc_draws, 41:66, 41:66)\n# ``` \n# ```{.julia}\n# idxs = vcat(2:4, 45:47)\n# PairPlots(bc_mc_draws, idxs, idxs)\n# ```\n# ```{.julia}\n# PairPlots(mc_draws, idxs, idxs)\n# ``` \n# ```{.julia}\n# cov_sqrt(what::UnconstrainedDraws) = sqrt(cov(what.unconstrained_draws))\n# pca_sqrt(what::UnconstrainedDraws) = (\n#     e = eigen(cov(what.unconstrained_draws));\n#     e.vectors * Diagonal(sqrt.(e.values))\n# )\n# Statistics.mean(what::UnconstrainedDraws) = mean(what.unconstrained_draws, dims=1)\n# whitened(what::UnconstrainedDraws) = DynamicObjects.update(\n#     what, unconstrained_draws=(\n#         what.unconstrained_draws .- what.mean\n#     ) / what.cov_sqrt' \n# )\n# pcad(what::UnconstrainedDraws) = DynamicObjects.update(\n#     what, unconstrained_draws=(\n#         what.unconstrained_draws .- what.mean\n#     ) / what.pca_sqrt' \n# ) \n# PairPlots(mc_draws.whitened, 1:20, 1:66)\n# # mc_draws.unconstrained_draws .- reshape(mc_draws.mean, (1, :))\n# # Statistics.cov(what::UnconstrainedDraws) = cov(what.unconstrained_draws)\n# # corr(what) = (\n# #     C = cov(what);\n# #     S = Diagonal(sqrt.(diag(C)));\n# #     S \\ C / S\n# # )\n\n# # square(x) = x^2\n# # argsort(x; kwargs...) = sort(1:length(x), by=i->x[i]; kwargs...)\n# # reverse(argsort(\n# #     maximum(abs.(eigen(cov(mc_draws.unconstrained_draws)).vectors), dims=2)\n# # ))'\n# ```  \n# ```{.julia}\n# # PairPlots(mc_draws.pcad, 1:20, 1:20)\n# PairPlots(mc_draws.pcad, 1:20, 1:66)\n# # reverse(argsort(\n# #     maximum(abs.(eigen(corr(mc_draws.unconstrained_draws)).vectors), dims=2)\n# # ))'\n# ``` \n# ```{.julia}\n```\n\n",
    "supporting": [
      "posteriordb_independent_files/figure-html"
    ],
    "filters": [],
    "includes": {}
  }
}