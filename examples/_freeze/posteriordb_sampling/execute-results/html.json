{
  "hash": "f9ce9bd3443ce33457961eef3483c4bf",
  "result": {
    "markdown": "---\ntitle: Using posteriordb posteriors\nexecute:\n  daemon: 999999\n---\n\n```{.julia}\nif pwd()[end] != 's'\n    using Revise\n    using Pkg\n    cd(\"examples\")\n    Pkg.activate(\".\")\nend\nincludet(\"common.jl\")\nRandom.seed!(1) \n\n@dynamic_object MarkovChain distribution::DynamicDistribution no_draws initial_parameters adapt=false\nno_dimensions(what::MarkovChain) = what.distribution.no_dimensions\nmetric(what::MarkovChain) = DiagEuclideanMetric(what.distribution.no_dimensions)\nhamiltonian(what::MarkovChain) = Hamiltonian(what.metric, what.distribution, ReverseDiff)\nintegrator(what::MarkovChain) = Leapfrog(1.)\ncompleted(what::MarkovChain) = DynamicObjects.update(what, :stepsize_draws_stats)\ncompleted(what::MarkovChain, no_draws; kwargs...) = DynamicObjects.update(\n    what, no_draws=no_draws; kwargs...\n).completed\n\nfunction stepsize_draws_stats(what::MarkovChain)\n    no_draws = what.no_draws\n    initial_parameters = what.initial_parameters\n    adapt = what.adapt\n    hamiltonian = what.hamiltonian\n    integrator = what.integrator\n    proposal = NUTS{MultinomialTS, GeneralisedNoUTurn}(integrator)\n    if adapt\n        adaptor = StepSizeAdaptor(0.8, integrator)\n        samples, stats = sample(\n            hamiltonian, proposal, initial_parameters, no_draws, adaptor, no_draws; \n            progress=true, verbose=false\n        )\n        AdvancedHMC.finalize!(adaptor)\n        return adaptor.state.Ïµ, hcat(samples...)', stats\n    else\n        samples, stats = sample(\n            hamiltonian, proposal, initial_parameters, no_draws; \n            progress=true, verbose=false\n        )\n        return 1., hcat(samples...)', stats\n    end\nend \nstepsize(what::MarkovChain) = what.stepsize_draws_stats[1]\ndraws(what::MarkovChain) = what.stepsize_draws_stats[2]\nstats(what::MarkovChain) = what.stepsize_draws_stats[3]\nunreparametrized_draws(what::MarkovChain) = unreparametrize(what.distribution, what.draws)\nunreparametrized_stds(what::MarkovChain) = std.(eachcol(what.unreparametrized_draws))\nunreparametrized_esss(what::MarkovChain) = ess(\n    reshape(what.unreparametrized_draws, (size(what.draws, 1), 1, size(what.draws, 2)))\n)\nunreparametrized_effs(what::MarkovChain) = what.unreparametrized_esss ./ sum(what.stats_df.n_steps)\nrescaled_distribution(what::MarkovChain) = rescale(what.distribution, [what.stepsize])\nfinal_parameters(what::MarkovChain) = what.draws[end, :]\nrescaled(what::MarkovChain) = MarkovChain(\n    what.rescaled_distribution, what.no_draws, what.stepsize .\\ what.final_parameters, what.adapt\n)\nfunction reparametrized_distribution(what::MarkovChain)\n    display(what.stats_df_description)\n    repa_distribution = what.distribution\n    base_distribution = repa_distribution.distribution\n    if hasproperty(base_distribution, :wrapper)\n        draws = unreparametrize(repa_distribution, what.draws)\n        # println(\"Obtained odraws: $(typeof(odraws)), $(size(odraws))\")\n        bc = base_distribution.wrapper(draws).best_centeredness\n        println(\"Obtained bc: $(bc)\")\n        repa_distribution = recenter(base_distribution, bc)\n        # println(\"Recenterd distributions\")\n        draws = reparametrize(repa_distribution, draws)\n        rescale(repa_distribution, std.(eachcol(draws)))\n    else\n        # repa_distribution = base_distribution\n        rescale(what.distribution, std.(eachcol(what.draws)))\n    end\n    # println(\"Reparametrized draws\")\n    # rescale(repa_distribution, std.(eachcol(draws)))\nend   \nfunction reparametrized(what::MarkovChain)\n    repa_distribution = what.reparametrized_distribution\n    initial_parameters = reparametrize(\n        repa_distribution, unreparametrize(what.distribution, what.final_parameters)\n    )\n    MarkovChain(repa_distribution, what.no_draws, initial_parameters, what.adapt)\nend\nstats_df(what::MarkovChain) = DataFrame(what.stats)\nstats_df_description(what::MarkovChain) = describe(what.stats_df)[[1,3,9], 1:5]\n# MCMCDiagnosticTools.ess(what::MarkovChain) = ess(what.unreparametrized_draws)\n\nBase.show(io::IOContext{IOBuffer}, what::MarkovChain) = (\n    display(describe(what.stats_df)[[1,3,9], 1:5]);\n    display(PairPlots(what.draws))\n    # display(plot(what.distribution.reparametrization.reparametrizations[end].reparametrizations[end].centeredness))\n)  \n \n@dynamic_object MarkovChainComparison chains::AbstractVector \nlhs(what::MarkovChainComparison) = what.chains[1]\nno_pairplot_parameters(what::MarkovChainComparison) = 20\n# pairplot_idxs(what::MarkovChainComparison) = sort(\n#         sample(axes(what.lhs.draws, 2), \n#         min(what.no_pairplot_parameters, size(what.lhs.draws, 2)), replace=false\n#     )\n# )\nfunction pairplot_idxs(what::MarkovChainComparison)\n    # println(size(unreparametrized_esss(what.chains[1])))\n    # stds = hcat(unreparametrized_stds.(what.chains)...)\n    effs = hcat(unreparametrized_effs.(what.chains)...)\n\n    metric = vec(minimum(effs, dims=2))\n    no_parameters = length(metric)\n    sort(\n        sort(1:no_parameters, by=i->metric[i])[\n            1:min(no_parameters, what.no_pairplot_parameters)\n        ]\n    )\nend\nBase.show(io::IOContext{IOBuffer}, what::MarkovChainComparison) = (\n    display.(stats_df_description.(what.chains));\n    display(plot(hcat(unreparametrized_effs.(what.chains)...)));\n    pairplot_idxs = what.pairplot_idxs;\n    display(sum([\n        PairPlots(chain.unreparametrized_draws, pairplot_idxs) for chain in what.chains\n    ]))\n)\n\ninitial_parameters(what::DynamicDistribution) = zeros(what.no_dimensions)\ninitial_stepsize(what::DynamicDistribution) = 1.\nfunction adaptation(what::DynamicDistribution)\n    initial_parameters = what.initial_parameters\n    while !all(isfinite.(log_density_gradient(what.model, initial_parameters)[2]))\n        initial_parameters = randn(size(initial_parameters))\n    end\n    what = rescale(what, [what.initial_stepsize])\n    mc = MarkovChain(what, 75, what.initial_stepsize .\\ initial_parameters, true).completed.rescaled\n    for no_draws in [25, 50, 100, 200, 500]\n        mc = completed(mc, no_draws).reparametrized\n    end\n    completed(mc, 50).rescaled\nend \nadapted_draws(what::DynamicDistribution) = completed(what.adaptation, 1000, adapt=false)\n```\n```{.julia}\nwhat = DynamicObjects.cached(\n    PDBPosterior(\"eight_schools-eight_schools_centered\").bridgestan_distribution, \n    :adapted_draws\n)\nwhata = DynamicObjects.cached(\n    DynamicObjects.update(\n        PDBPosterior(\"eight_schools-eight_schools_centered\").bridgestan_distribution, \n        wrapper=eight_schools_wrapper,\n        centeredness=1\n    ), \n    :adapted_draws\n)\nMarkovChainComparison([whata, what])\n```\n```{.julia}\nwhat = DynamicObjects.cached(\n    PDBPosterior(\"radon_mn-radon_hierarchical_intercept_centered\").bridgestan_distribution, \n    :adapted_draws\n)\nwhata = DynamicObjects.cached(\n    DynamicObjects.update(\n        PDBPosterior(\"radon_mn-radon_hierarchical_intercept_centered\").bridgestan_distribution, \n        wrapper=radon_wrapper,\n        centeredness=1\n    ), \n    :adapted_draws\n)\nMarkovChainComparison([whata, what])\n```   \n```{.julia}\nwhat = DynamicObjects.cached(\n    PDBPosterior(\"radon_all-radon_hierarchical_intercept_centered\").bridgestan_distribution, \n    :adapted_draws\n)\nwhata = DynamicObjects.cached(\n    DynamicObjects.update(\n        PDBPosterior(\"radon_all-radon_hierarchical_intercept_centered\").bridgestan_distribution, \n        wrapper=radon_wrapper,\n        centeredness=1\n    ), \n    :adapted_draws\n)\nMarkovChainComparison([whata, what])\n```  \n```{.julia}\nwhat = DynamicObjects.cached(\n    PDBPosterior(\"radon_all-radon_variable_intercept_slope_centered\").bridgestan_distribution, \n    :adapted_draws\n)\nwhata = DynamicObjects.cached(\n    DynamicObjects.update(\n        PDBPosterior(\"radon_all-radon_variable_intercept_slope_centered\").bridgestan_distribution, \n        wrapper=radon_is_wrapper,\n        centeredness=1\n    ), \n    :adapted_draws\n)\nMarkovChainComparison([whata, what])\n```     \n```{.julia}\nwhat = DynamicObjects.cached(\n    DynamicObjects.update(\n        PDBPosterior(\"mcycle_gp-accel_gp\").bridgestan_distribution, \n        initial_parameters=vec(mean(PDBPosterior(\"mcycle_gp-accel_gp\").unconstrained_draws, dims=1)),\n        initial_stepsize=1e-1\n    ), \n    :adapted_draws\n) \nwhata = DynamicObjects.cached(\n    DynamicObjects.update(\n        PDBPosterior(\"mcycle_gp-accel_gp\").bridgestan_distribution, \n        wrapper=motorcycle_wrapper,\n        centeredness=0,\n        initial_parameters=vec(mean(PDBPosterior(\"mcycle_gp-accel_gp\").unconstrained_draws, dims=1)),\n        initial_stepsize=1e-1\n    ), \n    :adapted_draws\n)\nMarkovChainComparison([whata, what])\n# PairPlots(what.draws)\n```    \n```{.julia}\n```   \n\n",
    "supporting": [
      "posteriordb_sampling_files/figure-html"
    ],
    "filters": [],
    "includes": {}
  }
}