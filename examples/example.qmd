---
title:  WarmupHMC.jl example
jupyter: julia-1.8
execute:
  daemon: 999999
---

```{julia}
using DynamicObjects, WarmupHMC
using Distributions, Statistics, LinearAlgebra, ForwardDiff
using Plots

@dynamic_object WarmupWindow no_iterations::Integer type
 
@dynamic_object StanWarmup no_iterations::Number
warmup_windows(what::StanWarmup) = [
  WarmupWindow(75, :scale)
  WarmupWindow(25, :metric)
  WarmupWindow(50, :metric)
  WarmupWindow(100, :metric)
  WarmupWindow(200, :metric)
  WarmupWindow(500, :metric)
  WarmupWindow(50, :scale)
]

Distributions.logpdf(what::DynamicObject, parameters) = logpdf(what.distribution, parameters)
no_dimensions(what::DynamicObject) = length(what.distribution)
logpdf_gradient(what::DynamicObject, parameters) = ForwardDiff.gradient(
  theta->logpdf(what, theta), parameters
)

@dynamic_object IndependentKernel distribution::Distribution
@dynamic_object IndependentKernel distribution::DynamicObject
transition(what::IndependentKernel, last) = rand(what.distribution)

@dynamic_object MetropolisKernel distribution::Distribution covariance_estimate
@dynamic_object MetropolisKernel distribution::DynamicObject covariance_estimate
jump_distribution(what::MetropolisKernel) = MvNormal(
  zeros(what.no_dimensions), what.covariance_estimate
)
function transition(what::MetropolisKernel, last)
  proposal = last .+ rand(what.jump_distribution)
  if rand() < exp(logpdf(what, proposal) - logpdf(what, last))
    proposal
  else
    last
  end
end

@dynamic_object Warmup kernel procedure
# no_dimensions(what::Warmup) = length(what.kernel.distribution)
warmup_windows(what::Warmup) = what.procedure.warmup_windows
regularize(sample_covariance, no_draws, regularization_no_draws=5, regularization_constant=1e-3) = (
  no_draws / ((no_draws + regularization_no_draws) * (no_draws - 1)) * sample_covariance + regularization_constant * (regularization_no_draws / (no_draws + regularization_no_draws)) * I
)
covariance(what::DynamicObject) = cov(what.distribution)
covariance_estimate(what::DynamicObject) = I 
function covariance_remaining(what::DynamicObject)
  ce = what.covariance_estimate
  L = isa(ce, UniformScaling) ? I : cholesky(ce).L
  return L \ what.covariance / L'
end
function kernels(what::Warmup)
  current_kernel = what.kernel
  rv = [current_kernel]
  no_dimensions = current_kernel.no_dimensions
  current_parameters = zeros(no_dimensions)
  for window in what.warmup_windows
    samples = zeros((window.no_iterations, no_dimensions))
    gradients = zeros((window.no_iterations, no_dimensions))
    for iteration in 1:window.no_iterations
      current_parameters .= transition(current_kernel, current_parameters)
      samples[iteration, :] .= current_parameters
      gradients[iteration, :] .= logpdf_gradient(current_kernel, current_parameters)
    end
    scov = cov(samples)
    gcov = cov(gradients)
    if window.type == :metric
      # covariance_estimate = regularize(Symmetric(scov), window.no_iterations)
      covariance_estimate = regularize(Diagonal(sqrt.(diag(scov) ./ diag(gcov))), window.no_iterations)
      current_kernel = DynamicObjects.update(
        current_kernel, covariance_estimate=covariance_estimate
      )
      push!(rv, current_kernel)
    end
  end
  return rv
end

showcase(no_dimensions::Integer=10) = showcase(
  MvNormal(randn(no_dimensions), Diagonal(exp.(randn(no_dimensions))))
)
function showcase(distribution)
  sw = StanWarmup(1000)
  ikernels = Warmup(IndependentKernel(distribution), sw).kernels
  mkernels = Warmup(MetropolisKernel(distribution, I), sw).kernels
  iconds = cond.(covariance_remaining.(ikernels))
  mconds = cond.(covariance_remaining.(mkernels))
  conds = vcat(iconds, mconds)
  plot(
    [iconds, mconds], yaxis=:log, ylim=[1, maximum(conds)], marker=:circle
  )
end
showcase()
```
```{julia}
@dynamic_object NealsFunnel centeredness::Vector
no_dimensions(what::NealsFunnel) = 1+length(what.centeredness)
Base.length(what::NealsFunnel) = what.no_dimensions
centeredness_estimate(what::NealsFunnel) = ones(length(what.centeredness))
centeredness_remaining(what::NealsFunnel) = what.centeredness_estimate - what.centeredness
Statistics.cov(what::NealsFunnel) = I
function Distributions.logpdf(what::NealsFunnel, parameters) 
  log_sd = parameters[1]
  sd = exp(log_sd)
  logpdf(Normal(), log_sd) + sum(logpdf.(Normal.(0, sd.^what.centeredness_remaining), parameters[2:end]))
end
function Base.rand(what::NealsFunnel)
  xis = randn(what.no_dimensions)
  log_sd = xis[1]
  sd = exp(log_sd)
  return vcat(log_sd, sd.^what.centeredness_remaining .* xis[2:end])
end

showcase(NealsFunnel(zeros(5)))
``` 