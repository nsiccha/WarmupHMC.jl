---
title:  Approximately whitening a normal distribution
---
```{julia}
using WarmupHMC
using LinearAlgebra, Distributions, LogDensityProblems, Random

struct StdNormalPosterior
    N::Int
end
LogDensityProblems.dimension(what::StdNormalPosterior) = what.N
LogDensityProblems.capabilities(::Type{<:StdNormalPosterior}) = LogDensityProblems.LogDensityOrder{1}()
LogDensityProblems.logdensity(::StdNormalPosterior, x) = sum(logpdf.(Normal(), x))
LogDensityProblems.logdensity_and_gradient(what::StdNormalPosterior, x) = LogDensityProblems.logdensity(what, x), -x

```
```{julia}
rng = Xoshiro(0)
n_parameters = 20
rdist = StdNormalPosterior(n_parameters)
scaling = Diagonal((exp.(-sort(randn(rng, n_parameters)))))
display(diag(scaling)')
display(1 ./ diag(scaling)')
rotation = qr(randn(rng, (n_parameters, n_parameters))).Q
dist = WarmupHMC.ScaledLogDensity(
    rdist,
    scaling * rotation
)

dists = [
    approximately_whitened(dist; rng=Xoshiro(i), twosided=ts)# |> approximately_whitened
    for i in 1:40, ts in [true, :first, false]
]
conds = cond.(getproperty.(dists, :transform))
display((cond(dist.transform)))
display(exp.(mean(log.(conds), dims=1)))
# display(mean(log.(conds[:, 1:2] ./ conds[:, 3]), dims=1))
```
```{julia}
struct ProductPosterior{T}
    dists::Vector{T}
end
LogDensityProblems.dimension(what::ProductPosterior) = length(what.dists)
LogDensityProblems.capabilities(::Type{<:ProductPosterior}) = LogDensityProblems.LogDensityOrder{1}()
LogDensityProblems.logdensity(what::ProductPosterior, x) = sum(logpdf.(what.dists, x))
LogDensityProblems.logdensity_and_gradient(what::ProductPosterior, x) = LogDensityProblems.logdensity(what, x), gradlogpdf.(what.dists, x)
```
```{julia}
rng = Xoshiro(0)
n_parameters = 20
rdist = ProductPosterior([TDist(3) for i in 1:n_parameters])
scaling = Diagonal((exp.(-2sort(randn(rng, n_parameters)))))
display(diag(scaling)')
display(1 ./ diag(scaling)')
rotation = qr(randn(rng, (n_parameters, n_parameters))).Q
dist = WarmupHMC.ScaledLogDensity(
    rdist,
    scaling * rotation
)

dists = [
    approximately_whitened(dist; rng=Xoshiro(i), twosided=ts)
    for i in 1:40, ts in [true, :first, false]
]
conds = cond.(getproperty.(dists, :transform))
display((cond(dist.transform)))
display(exp.(mean(log.(conds), dims=1)))
# display(mean(log.(conds[:, 1:2] ./ conds[:, 3]), dims=1))
```